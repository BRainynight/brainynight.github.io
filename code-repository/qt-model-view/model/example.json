[
    {
        "metadata": {
            "title": "blog-seo",
            "description": "邁向讓Google收錄文章的心路歷程",
            "date": "2022-06-05T19:31:25",
            "tags": [
                "hexo"
            ],
            "aliases": [
                "/posts/2022-06-05-blog-4-seo",
                "/posts/2022-06-05-blog-4-seo.html"
            ]
        },
        "content": "這是一篇在部落格架設之初，嘗試使用 Google Search Console 時的苦痛新路歷程，多數內容是當時所寫。幾乎是每日每日更新當天的發現、新的疑難雜症，因此可能每個段落的「今天」都不一樣(尷尬)，但文章中都有把實際的日期標上去，請以相對時間的角度來閱讀本文!\n\n我並不是專業於網頁前端、SEO 的人，或許文中的推斷與說明會有偏差，但仍嘗試將過程中的試誤以及解決辦法給紀錄下來，對錯與否還請自行斟酌!\n\n------\n\n首先，網頁架設之後如果搜尋引擎沒有收錄，就沒辦法讓網頁在使用者搜尋時被搜索到。Google 的爬蟲「有可能」可以主動探勘到部落格，但或許更大的機率是不會，畢竟現在網路這麼發達，爬蟲很忙的。\n\n要知道自己的網頁是否有被爬蟲收錄，可以直接在搜尋引擎上打 `site:<你的網址>`，像是要看本部落格在搜尋引擎的收錄狀況如下:\n\n```\nsite:brainynight.github.io\n```\n\n我們要做的事情是，讓自己的網頁在搜尋引擎登記在案! 使用的是 Google Search Console 的服務。有關如何登記，可以參考此篇文章: [【完整指南】2022 Google Search Console教學(附索引問題處理) - SEO分解茶](https://www.seo-tea.com/google-search-console-tutorial/)。\n\n本文接下來所分享的內容，是有關我在 Google Search Console 建立網域、登記 Sitemap 之後所遇到的問題。\n\nPS. 在 2022/09 前後，Google 有修改一次搜尋引擎的策略，用 `site:XXX` 看收錄了哪些網站似乎不再管用，與在 Google Search Console 當中看到編入索引數量並不一致，顯示的只有熱門的幾篇文章。\n\n## 提交 Sitemap 後等很久\n\n![image20220126135547909](/uploads/sitemapfail.png)\n\n圖中的三個網址，有兩個是拿來嘗試此情況下 Google 會顯示何狀態，只有 `sitemap.xml` 是我真正希望爬蟲看到的。\n\n- `sitemap_index.xml`: 在我的網頁中不存在，404 not found。Google 的狀態顯示「無法擷取」但點進去之後有寫到錯誤原因: `無法讀取 Sitemap: 一般的 HTTP 錯誤`。\n\n  > 我們嘗試存取您的 Sitemap 時發生錯誤。請確定您的 Sitemap 符合我們的指南，而且可由您提供的位置存取，確認都沒有問題後再重新提交。 示例 HTTP 錯誤：404\n\n- `robots.txt`: 他本身不是 xml 檔案，我在提交 robots.txt 的頁面有提交過，可以成功爬取。可讀取 Sitemap，但其中含有錯誤。\n\n  > 不受支持的檔案格式。您的 Sitemap 格式似乎不受支援。請確認它符合我們的《Sitemap 指南》，然後重新提交。\n\n- `sitemap.xml`: 真正的 sitemap，我確定 google 是可以存取他的，但不知道為何就是顯示無法擷取，點進去的內容也只有「無法讀取 Sitemap」。\n\n網路上關於 sitemap 沒辦法被截取有很多解釋，主要歸類如下:\n\n1. 真的有問題: 如格式不對 (含有 noindex, 不符合 sitemap 規範的幾種格式)、網址不存在 (404)\n2. 沒問題，只是 Google 機器人還沒時間爬。\n\n主要就是如果可以確認自己的 sitemap 屬於後者，就只能等。幾天到幾個禮拜不一定... ，這兩篇文章可以參考:\n\n- [Google search console fails to fetch sitemaps | \"Sitemap could not be read\"](https://stackoverflow.com/questions/53921636/google-search-console-fails-to-fetch-sitemaps-sitemap-could-not-be-read)\n\n- [Sitemap could not be read (Couldn’t fetch) in Google Search Console](https://www.jcchouinard.com/sitemap-could-not-be-read-couldnt-fetch-in-google-search-console/)\n\n  如果狀況如下圖，可能如作者所言，就只是 google 引擎還沒抓到。\n\n  ![img](https://www.jcchouinard.com/wp-content/uploads/2021/07/image-4.png.webp)\n\n## Sitemap 被讀取成功\n\n大約是 1/25 晚上第一次提交 sitemap，1/27 早上看到頁面轉為通過 (快樂)。\n\n在一直不通過的期間我到處爬文，除了上面說的 googlebot delay 的關係，還有一個是 google 難以在茫茫大海中找到這個網站。由於之前有在 Medium 上寫作，知道它的 SEO 做的很好，所以在 Medium 上面發了一篇轉站的文章。\n\n今天早上 (1/27) 不但看到 sitemap 通過了，還發現我的 Blog 首頁在 **網址審查** 那邊，來源是從 Medium 來的!\n\n```\n發現方式\nSitemap: https://brainynight.github.io/sitemap.xml\n參照網頁: <我的 medium blog 網址>\n```\n\n恩，雖然它依然顯示 **網址不在 Google 服務中 (已找到 - 目前尚未建立索引)** 。但這個階段，在 google 找自己的網域(文章一開始說的搜索方式)還是找不到東西的。\n\n網路上說「找到」直到「建立索引」的階段，可能要長達一周以上，反正就慢慢等囉。\n\n## 所申請的主頁被索引成功\n\n1/30 中午 11 點! 我的部落格首頁被索引成功!\n\n一早 10 點起來還沒被索引，我查了一下有利 SEO 的條件基本上要利於手機檢索，於是開始調整東調整西。這之間我曾經嘗試調整字體，然而字體是外部資源，因此會耗費載入時間。對於 Hexo Next 這個主題我所做的優化，都記錄在文章[Hexo Blog 客製化 (3) Next 主題加速](/posts/2022-01-26-blog-3-speedup)當中。諷刺的是，最影響效能的其實就是字體跟外載入的資源! 我把 `min.js` (來自 fontawsome 提供 icon 的) 跟字體客製化都關掉用最原始的預設字體。結果效率分數直接拉到 99~100。\n\n也就是說，甚麼美化都不搞其實更有利於檢索....。由於之前我的 sitemap 有被接收過，其中網址的狀態都被標示沒安排索引，原因是怕伺服器撐不住，我猜測是因為載入過慢的問題，因此做了這樣的調整。也不知道有沒有因果關係，總之做了這一些調整後，首頁被 googel 爬蟲臨幸拉! (快樂)\n\n可以使用 google 引擎看一下自己的收錄狀況，要注意 `site` 跟 `url` 之間不能有空格!\n\n```\nsite:<your url> [keyword]\n# Example: \nsite:https://brainynight.github.io\nsite:https://brainynight.github.io pickle\n```\n\n## 我的網頁有變更，Google 沒看到\n\nGoogle 搜尋引擎的演算法策略不斷改變，數位世代的網頁增長數量也非常快。Google 難以將全世界所有的網頁都收錄一遍、且隨時即時更新。使用 wordpress 或用 github page 自己架設部落格時，SEO 問題就需要自己一盤抓。\n\n而像這種個人的小部落格，Google 的更新頻率不快，即使它已經收錄了 sitemap，也不會有更新就看到。像是現在 2/2 而我的 sitemap 上次被看的時間是 1/27 !\n\nGoogle 的官方說明文件[要求 Google 重新檢索網址](https://developers.google.com/search/docs/advanced/crawling/ask-google-to-recrawl?visit_id=637793786640453064-2510441601&rd=1)中提及:\n\n- 我們可以用「網址檢查工具」看單一網頁上次被檢索的時間得知狀態，網站數量不多時，我們可以在單一頁面的檢索狀態上按「要求建立索引」來提交，但 Google 對這個通路有數量限制。\n\n- 或是用「索引狀態報表」查看 Sitemap 中有收錄的網址的狀態。提交大量網址時，一般建議使用 Sitemap。如果尚未在 Google Console 中提交 Sitemap 、或是提交後 Google 還沒接受（狀態還不是成功），這個報表是用不到的。\n\n現在面臨的狀況是：我曾經提交 Sitemap 但後來有網址的發布方式，然而 Google 所存檔的是我舊的網址連結。想要讓 Google 知道我的網址都變更了。\n\n### 通知 google 網站已經變更\n\n官方文件[將 Sitemap 提交給 Google](https://developers.google.com/search/docs/advanced/sitemaps/build-sitemap#addsitemap) 裡面有這樣一段話\n\n> Google 不會在每次檢索網站時檢查 Sitemap。除非您透過連線偵測 (ping) 告知我們 Sitemap 有異動，否則我們只會在首次偵測到 Sitemap 時進行檢查。如果您並未新增或更新 Sitemap，請勿要求 Google 檢查 Sitemap；也不要重複提交相同的 Sitemap 或為其執行連線偵測 (ping)。\n\n簡單來說：\n\n1. Google第一次偵測到 Sitemap 的時候會對裡面進行檢查，之後不會每次檢索的時候都去看 Sitemap。\n2. 所以如果 Sitemap 有變更，Google 沒看到要 Ping 一下它。\n3. 如果有已經存在的網頁有更新，要使用 `<lastmod>`標記這些網頁。\n\n有兩種方式讓 Google 存取 Sitemap\n\n1. 尚未讓 Google 收藏過 Sitemap：建議在 Google Console 中提交 [Sitemap 報告](https://support.google.com/webmasters/answer/7451001)\n2. 使用連線偵測 (ping) 工具：在網址中傳送 GET 要求：\n\n   ```\n   https://www.google.com/ping?sitemap=<你的sitemap完整網址(包括https)>\n   ```\n\n## 小技巧: 將 Search Console 的版面切成英文\n\n在參數列添加 `&hl=en` 可以直接將 google console 的報表直接轉換成英文，用英文的 Keyword 在搜尋引擎上查，可以得到比較多相關資料! 中文的討論串實在有點少。\n\n## 分享一下 Sitemap 被光顧的時間頻率\n\n需要注意的是，Google Console 的各表格更新時間**並不一致**！因此有些問題可能會沒辦法即時反應。例如，明明 Sitemap 在 2/5 被讀取了，然而涵蓋範圍頁面的更新日期卻停留在 2/2，因此我沒辦法知道這一次 Google 更新的網址有哪些，也沒辦法知道 Google 有沒有試圖對它們爬蟲、是不是我的頁面有問題等等，只能等。等它的統計表單更新... 。\n\n而包含成效(有多少點擊量)、涵蓋範圍、行動裝置可用性、檢索統計資料，每張表格的更新日期都是不一致的！以我寫這段文字的時間，他們的更新時間分別是 5小時前、2/1、 2/4、 2/2。因此「行動裝置頁面」的有效網頁數量反而比「涵蓋範圍」多，顯得有點弔詭。\n\n- 1/25 第一次提交 sitemap\n- 1/27 Sitemap 第一次被讀取，但沒有任何網頁被收錄。顯示「已找到、目前尚未建立索引」\n- 1/30 11:00 首頁被索引收錄成功，期間進行手機與電腦板的網頁載入速度優化。\n\n2月：修改 **文章 (post)** 網址的格式，也就是說 Google 收錄的 sitemap 內容，與我當前的網址不一致，只能等待 Google 再爬到我的 sitemap 發現有更新，才能同步兩邊的網址內容。而 tag 頁面的網址沒有被改，跟 sitemap 是一致的。期間，當我手動為 tag 進行索引提交，這些網頁幾乎都當天就被收錄了，而文章頁面則都被不理會。\n\n- 2/5 10:00 發現 Sitemap 被更新，距離上次被讀取相隔將近 9 天，一共處理 25 個網址。\n- 2/6 11:00 發現 Sitemap 連續兩天被臨幸，顯示「Sitemap已處理完畢」一共有 25 個網址。\n  - 然而涵蓋範圍內標示的網址都是舊網址，且總數只有 22 個。\n  - 從網址檢查工具那邊查看，舊網址沒有被 sitemap 收錄，新網址（現在正常的）則都有被收錄。\n  - 另外出現一個轉址錯誤，可是我透過其他工具看轉址都是正常的。\n  - 發現有一個網址顯示「已檢索 - 目前尚未建立索引」，很難過以為被嫌棄了。\n- 2/6 22:00 發現那個原本「已檢索 - 目前尚未建立索引」的網頁被收錄了，是我第一篇真正被收錄的文章（目前為止都是 tag 類的頁面被收錄）！雖然當前在 Google 引擎上我還是看不到。\n- 2/9 涵蓋範圍終於更新成我修改後的網址、並且網址數量和與我當前的 sitemap 一致。也就是說從我提交新的網址到涵蓋範圍變動之間大約 7~10 天才在報表上生效，若單論修改到爬蟲來光顧 Sitemap 間隔大約 5天。但目前也只有一篇手動提交的網址被檢索並建立索引，其他都還是「已找到、目前尚未建立索引」\n- 2/5~2/10 連續 6 天被 Google 爬蟲臨幸，文章介面實際被爬取的有 3 篇，其他時候都是一些 tag 頁面被爬 (可以去設定那邊的「檢索統計資料、依發現方式」看有多少文章被爬到）\n- 5月初爬蟲有再來連續光顧 7天，但其間個人忙碌，沒有更新文章。\n- 6/3 爬蟲又來了一天，結果我是隔天才更新文章 (掩面)。\n\n其實網路上許多人也都說了，爬蟲何時來只能耐心等候，我還是稍微紀錄了一下對於這個新開的站，爬蟲光顧的頻率以及我個人所遇到的狀況，如何應對。希望能夠提供給有類似問題的人一個經驗分享!!"
    },
    {
        "metadata": {
            "title": "deploy-docsy-to-github-page",
            "date": "2024-05-03T23:09:00",
            "description": "實際部屬到 github Page 時遇到的困難",
            "categories": [
                "Default@"
            ]
        },
        "content": "## 前情概要\n- [從零開始 Docsy (1)](../start-with-docsy-1)\n- [從零開始 Docsy (2)](../start-with-docsy-2)\n\n## 正式上線\n\n[Docsy 官方](https://www.docsy.dev/docs/get-started/docsy-as-module/start-from-scratch/)有提供「白手起家」的 command 該怎麼寫: \n\n```bash\n# initialize site \nhugo new site my-new-site\ncd  my-new-site\n# init mod and add require \nhugo mod init github.com/me/my-new-site\nhugo mod get github.com/google/docsy@v0.10.0\n# add config\ncat >> hugo.toml <<EOL\n[module]\nproxy = \"direct\"\n[[module.imports]]\npath = \"github.com/google/docsy\"\nEOL\nhugo server\n\n```\n\n透過 `hugo new site`，`hugo` 會創建一些預設的資料夾，如 `content`, `assets` 等，不像前面得自己創建。\n在[先前的簡易範例](../start-with-docsy-2)中只改 config，無須更改網頁主體的內容，因此有無這些其他資料夾無直接影響。在實際上線時，要覆蓋 docsy 預設的 CSS 都得在 `assets/scss` 下加檔案，因此還是用 `hugo new site` 生成完整的架構。\n\n## 使用 Github Page 架站\n上網搜尋「架站」，已經可以找到許多資源，這裡不多贅述。如果從未有架站經驗，強烈建議閱讀這篇文章: [技術網站架設經驗雜談](https://www.ithome.com.tw/voice/148476)。先決定: 是否要付費買網域? \n\n對我來說，部落格像是一個 Side Project。不曉得更新頻率，也不曉得持續到甚麼時候，用且對 Github Page 已有經驗，因此決定繼續使用。Github Page 有一些[限制](https://docs.github.com/zh/pages/getting-started-with-github-pages/about-github-pages#usage-limits)，如果都可接受，那就繼續吧! \n### 關於 Github Page\n每個人的帳戶對應的網域名稱是: `<username>.github.io`，以我來說就是`brainynight.github.io`。\n\n你可以擁有多個 github page，但 `<username>.github.io` 只能對應一個專案，這個專案的名稱就必須跟網域有一樣的名稱。像這個網站對應的專案就是: [brainynight.github.io](https://github.com/BRainynight/brainynight.github.io) 。如果有多個 Github Page 需求，其他 Page 會變成 `<username>.github.io/<repository-name>`，被設成 Github Page 的專案必須是 Public 的。\n\n### 步驟\n具體步驟參考[官方說明](https://docs.github.com/zh/pages/quickstart)，使用 Hugo 還牽涉到 github action，這裡簡單修改步驟。\n1. 創建一個新的 repository，輸入 `<username>.github.io` 作為名稱\n  1. 如果是第二個 Github Page (已經有另一個 repository 名為`<username>.github.io`)，這裡就輸想要的名稱就好 (ex. second-blog)。\n2. 把剛才 `new site` 生成出的內容上傳到 Github repository\n3. 進到 repository，點設定\n4. 找到 \"Pages\" 的設定頁面\n5. **不同於 Github 教學文章!** 在 \"Build and deployment\" 選擇 \"Github Actions\"，參考 [Hugo-Host on GitHub Pages](https://gohugo.io/hosting-and-deployment/hosting-on-github/)的 Step4\n6. 在 Local repository，創建檔案 `.github/workflows/hugo.yaml`，內容複製 Hugo 說明的 Step6。記得 **Branch Name 跟 Hugo Version 要手動改成自己使用的版本!**。這個 Github Action 的觸發條件是當有內容 \"push\" 的時候。\n7. 在 Local repository commit 並且上傳到 Github\n8. 回到 Github repository，點選分頁 \"Actions\"，會看到有 workflow 清單，由於剛才設的動作是「當 Push 的時候執行」，因此現在正在跑。如果失敗了可以一步步點進去看 error message。\n9. 成功的話如下圖，可以到自己的網站看 Hugo Build 出來的內容了!\n    ![success](https://gohugo.io/hosting-and-deployment/hosting-on-github/gh-pages-4.png)\n\n\n## 失敗經驗\n\n在實際部屬時遇到問題: \n```\nError: error building site: POSTCSS: failed to transform \"scss/main.css\" (text/css). Check your PostCSS installation; install with \"npm install postcss-cli\". See [https://gohugo.io/hugo-pipes/postcss/:](https://gohugo.io/hugo-pipes/postcss/:) binary with name \"npx\" not found\n```\n\n我的解法參考自 [Hugo: postcss](https://gohugo.io/hugo-pipes/postcss/)，在自己 Local 的專案資料夾執行指令: \n```bash \nnpm i -D postcss postcss-cli autoprefixer\n```\n\n下指令後會下載一堆模組，把他們都加到 git 裡面，一起推上 github，我不確定是否為最佳解，不過問題解決了。"
    },
    {
        "metadata": {
            "title": "docsy-misc",
            "date": "2024-05-03T23:59:00",
            "description": "部屬 Docsy 時遇到的問題",
            "categories": [
                "Default"
            ]
        },
        "content": "我在嘗試加 `date` 屬性的時候發現，有些時間不會讓文章出現在列表上。\n首先，時間格式需要到秒:  2024/05/03 13:00:00。\n\n接著， 現在時間是 2024/05/03 21:52，我發現  2024/05/03 13:09:00 之後的文章，即使格式對了也不會出現在列表上。懷疑是否是時區問題 (台灣時間是 +8)，但此時此刻，21:52:00 的文章調整成 13:52:00 也仍不行。因此，寫好文章是要檢查一下有沒有成功被列上。\n\n**補充**: 現在時間 2024/05/05 12:05，我把昨天的文章恢復成真正的時間 (2024/05/03 21:52:00)，可以被列上清單了，可能真的是時區的問題。"
    },
    {
        "metadata": {
            "title": "hexo-1-build-env",
            "date": "2021-12-30T18:30:29",
            "tags": [
                "hexo"
            ],
            "description": "使用 Hexo 建立部落格並連動發布到 github page (github.io)上、文章發布、Hexo基本設定檔、NexT 主題設定檔...等初次使用的操作。",
            "aliases": [
                "/posts/2021-12-30-blog-0-hexo-build-env",
                "/posts/2021-12-30-blog-0-hexo-build-env.html"
            ]
        },
        "content": "## 前置作業\n\n1. 安裝 [Node.js](https://nodejs.org/en/) ，下載安裝檔後一路按到底，安裝完成。 \n\n2. 查看是否安裝成功：打開 CMD，輸入\n\n   ```sh\n   node -v\n   npm -v\n   ```\n\n   應該會顯示已經安裝的版本。\n\n3. 安裝 Hexo：打開 CMD 輸入\n\n   ```sh\n    npm install hexo-cli -g\n   ```\n\n   ```\n   added 57 packages, and audited 58 packages in 8s\n   \n   11 packages are looking for funding\n     run `npm fund` for details\n   \n   found 0 vulnerabilities\n   npm notice\n   npm notice New minor version of npm available! 8.1.2 -> 8.3.0\n   npm notice Changelog: https://github.com/npm/cli/releases/tag/v8.3.0\n   npm notice Run npm install -g npm@8.3.0 to update!\n   npm notice\n   ```\n\n   \n\n4. 查看 Hexo 是否安裝成功：看下面的指令有沒有成功顯示一些相關資訊\n\n   ```sh\n   hexo version \n   ```\n\n全部前置作業完成！\n\n## 初始化\n\n1. 建立一個資料夾，這裡創立 `blog-hexo`\n\n2. 進入資料夾，下指令：\n\n   ```sh\n   hexo init . \n   ```\n\n3. （仍在資料夾中）下指令安裝需要的 npm 套件\n\n   ```sh\n   npm install\n   ```\n\n   不需要安裝會出現象這樣的訊息：\n\n   ```sh\n   up to date, audited 249 packages in 976ms\n   \n   15 packages are looking for funding\n     run `npm fund` for details\n   \n   1 moderate severity vulnerability\n   \n   To address all issues (including breaking changes), run:\n     npm audit fix --force\n   \n   Run `npm audit` for details.\n   ```\n\n4. 可以嘗試 Demo 預設的網頁：\n\n   ```sh\n   hexo server\n   ```\n\n   \n\n## Hexo 設定檔\n\n現在我們回到 `blog-hexo` 資料夾中，注意到 `_config.yml` 設定檔。\n\n1. 其中 `theme` 參數是有關主題的參數，將它設置為想要的主題，這裡我想採用 `next`\n\n   ```yaml\n   # Extensions\n   ## Plugins: https://hexo.io/plugins/\n   ## Themes: https://hexo.io/themes/\n   theme: next \n   ```\n\n2. 到`theme`資料夾，將主題的 github 專案 clone 下來\n\n   ```sh\n   git clone https://github.com/theme-next/hexo-theme-next.git next\n   ```\n\n### 改地區\n\n```yaml\n# Site\ntitle: Blog Title\nsubtitle: ''\ndescription: ''\nkeywords: # 可以下一些對部落格的關鍵字，方便搜尋引擎找到\nauthor: Who\nlanguage: zh-TW # 改成 zh-TW, 大寫！不然在 hexo generate 時會變成阿拉伯文...\ntimezone: ''\n```\n\n### Github 部屬相關\n\n執行這個步驟前需要先在 Github 上創建倉庫，參見：[上傳到 Github 倉庫](#上傳到 Github 倉庫)。預設的情況通常倉庫名稱會建置為 `username.github.io`，以下就以預設的情況舉例說明。\n\n1. 部落格網址：\n\n   ```yaml\n   ## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\n   url: https://<使用者名稱>.github.io/\n   ```\n\n2. 使用 `hexo deploy` 到 Github 上面的參數選項：\n\n   ```yaml\n   deploy:\n     type: git\n     repo: https://github.com/username/username.github.io.git # http git clone 所給的網址\n     branch: master # 或 main, 看主要的 branch 名稱是什麼 \n   ```\n\n   `branch` 如果是由本地端使用 `git init .` 創建，預設的分支名稱會是 `master` 。但如果是在 github 倉庫上面創建先的話，預設會是 `main`。Hexo 可以部屬到很多地方，如果在這邊用了多個 `type`，可以在使用 deploy 時一口氣部屬到多個網站：[Deployment | Hexo](https://hexo.io/zh-tw/docs/one-command-deployment.html)\n\n   ```yaml\n   deploy:\n   - type: git\n     repo:\n   - type: heroku\n     repo:\n   ```\n\n## 主題設定檔\n\n### Scheme\n\n`Next` 主題中還有不同的排版模式，設定要進入 `theme/next/_config.yml` 修改：\n\n```yaml\nscheme: Gemini\n```\n\n### Menu 要顯示的內容\n\n```yaml\nmenu:\n  home: / || fa fa-home\n  about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  #categories: /categories/ || fa fa-th\n  archives: /archives/ || fa fa-archive\n  #schedule: /schedule/ || fa fa-calendar\n  #sitemap: /sitemap.xml || fa fa-sitemap\n  #commonweal: /404/ || fa fa-heartbeat\n```\n\n影響的是左邊 Menu 中顯示的分頁內容，預設只有 home 跟 archives，其他項目如果開起來的話預設的頁面(page) 還沒建立，會連不到內容。\n\n### [添加客製化(Custom) 的設定檔](https://oscarcx.com/tech/hexo-customize.html#%E5%85%B6%E5%AE%83%E6%94%B9%E5%8A%A8)\n\n將想添加的項目取消註解，這裡最簡單粗暴的只使用 `style`。寫在 `styles.styl` 中的 css 會被添加到最尾端，因此可以直接覆蓋默認的格式。\n\n```yaml\ncustom_file_path:\n  #head: source/_data/head.swig\n  #header: source/_data/header.swig\n  #sidebar: source/_data/sidebar.swig\n  #postMeta: source/_data/post-meta.swig\n  #postBodyEnd: source/_data/post-body-end.swig\n  #footer: source/_data/footer.swig\n  #bodyEnd: source/_data/body-end.swig\n  #variable: source/_data/variables.styl\n  #mixin: source/_data/mixins.styl\n  style: source/_data/styles.styl\n```\n\n\n\n## [第一篇文章](https://hexo.io/zh-tw/docs/writing)\n\n1. 執行下述指令，Hexo 會根據 Layout 的種類建立一個 markdown 檔案在對應的位置，Layout 預設為 Post。下面的指令就會在 `source/_posts` 下建立 `NewPost`\n\n   ```sh\n   hexo new [Layout] <PageName>\n   hexo new \"NewPost\"\n   ```\n\n   `source` 中是存放各種頁面 markdown 位置，`public` 中則是存已經渲染成 html 格式的檔案。\n\n   [Layout 的種類有三種](https://hexo.io/zh-tw/docs/writing#%E4%BD%88%E5%B1%80%EF%BC%88Layout%EF%BC%89)：\n\n   - `post `：預設種類，儲存的位置是 `source/_posts`\n\n   - `page`：路徑是 `source`，用途應該像是上面 Menu 環節中的 `Tags`, `About` 頁面需要創建時，就該輸入 `hexo new page Tags` 之類的吧。\n\n   - `draft`: 儲存路徑是 `source/_drafts` ，存在這裡的檔案不會顯示在頁面上。當要發布時，可以透過 \n\n     ```sh\n     hexo publish [layout] <draft_title>\n     ```\n\n     將草稿從 `_drafts` 挪到 `_posts` 或變成 `page` 之類的。\n\n     \n\n2. 來到 `source/_posts/NewPost.md` (應該還可以看到同層級還有一個 Hello world) ，預設的內容如下，紀錄了一些文章的 Metadata。\n\n   ```markdown\n   ---\n   title: NewPost\n   date: 2021-12-26 22:40:55\n   tags: tag1 tag2\n   ---\n   # 標題一\n   寫一些東西吧！\n   ```\n\n3. 到根目錄 `source` 上：\n\n   ```sh\n   hexo generate # 產生靜態 page \n   hexo server # Demo 在 localhost:4000 上\n   ```\n\n### scaffolds\n\n在創建文章的時候，根據 `layout` 種類，Hexo 會生成一個對應名稱的 .md 檔案在指定的路徑內。而這個檔案通常會有一些預設的內容，例如：`post` 格式就會有上一個章節中所展示的，有著預設的 metadata：`title`, `date`, `tags` 三個項目。\n\n如果想添加更多的屬性在預設產生的模板中，可以在 `scaffolds/post.md` 中添加。預設中的形式如下：\n\n```markdown\n---\ntitle: {{ title }}\ndate: {{ date }}\ntags:\n---\n```\n\n### 創造頁面(page)\n\n我們在[前面](#Menu 要顯示的內容)選擇了 Menu 裡面要顯示什麼，但如果取消註解了而沒有創建對應的頁面，在主頁上會顯示、但連進去之後會是 404。我們需要依照有列出的 page 創建對應的頁面：\n\n```sh\nhexo new page categories\nhexo new page tags\n```\n\n之類的。參見： [[筆記] 打造自己的 blog，Hexo + Github 之二](https://kemushi54.github.io/2019/04/01/%E7%AD%86%E8%A8%98-%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84-blog%EF%BC%8CHexo-Github-%E4%B9%8B%E4%BA%8C/)\n\n## 上傳 Github 與部屬網站\n\n### 上傳到 Github 倉庫\n\n1. 在 Github 創建一個名為  `<UserName>.github.io` 的倉庫，如果已經有過這個名稱，需要使用別的名稱創建倉庫名，可以參考這篇文章：[[教學]使用 GitHub Pages + Hexo 來架設個人部落格](https://ed521.github.io/2019/07/hexo-install/#gt-%E8%A8%AD%E5%AE%9A%E9%83%A8%E7%BD%B2%E8%87%B3-GitHub-%E7%9A%84%E8%B3%87%E8%A8%8A)\n\n2. 安裝插件\n\n   ```sh\n   npm install hexo-deployer-git --save\n   ```\n\n   沒安裝的話會出現 `ERROR Deployer not found: git`\n\n3. 在部落格資料夾中開啟 cmd，確認位置是在根目錄下（這篇的例子就是 `blog-hexo`）\n\n   ```sh\n   hexo cl # hexo clean 會把 public 內容刪掉\n   hexo g # hexo generate 建立靜態檔案\n   hexo d # hexo deploy 部屬到 _config 中有設置的地方\n   ```\n\n我的電腦因為本來就有跟自己的 github 倉庫做 ssh 連結，所以沒有跳出帳密驗證（還是過去已經有驗證過了但我忘記了？）。但看起來有些人在第一次部屬的時候會需要在跳出視窗登帳號。\n\n### [Hexo Deployer 的運作原理](https://github.com/hexojs/hexo-deployer-git#how-it-works)\n\n事實上，`hexo-deployer-git` 是將網站的靜態檔案產生在 `.deploy_git` 裡面，並使用強制推送(force pushing) 把東西推上  `<UserName>.github.io`。也因此，如果我們在根目錄或 `public` 資料夾再怎麼使用指令\n\n```sh\ngit remote -v \t  # 列出所有遠端伺服器\ngit log --oneline # git commit 紀錄\n```\n\n都不會看到什麼內容，但如果進去 `.deploy_git` 資料夾，一切都不同了。\n\n```sh\n$ git log --oneline\n0c468df (HEAD -> master) update blog\n7c6b6b6 First commit\n```\n\n但它的 git remote 清單裡面還是空的，我也還沒搞懂運作原理（汗顏\n\n\n\n### 保存當前的內容\n\n成功部屬後，進入  `<UserName>.github.io` 的倉庫，可以發現這個倉庫的內容基本上就是 `public` 資料夾的內容。並且我們可以在本地部落格中，透過 `git remote -v` 查看是否有遠端倉庫。（此用法參見：[Git-基礎-與遠端協同工作](https://git-scm.com/book/zh-tw/v2/Git-%E5%9F%BA%E7%A4%8E-%E8%88%87%E9%81%A0%E7%AB%AF%E5%8D%94%E5%90%8C%E5%B7%A5%E4%BD%9C) ）我這邊看起來是空蕩蕩，什麼都沒有。我希望在不同的平台上都可以撰寫部落格，想把當前的內容備份該如何？\n\nHexo 在幫我們初始化資料夾時已經有了一個 `.gititnore` 檔案，裡面已經將他們為了部屬而產生的資料夾給排除，也把 localhsot 在跑得時候所需要的 `public` 資料夾排除\n\n```gitignore\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n```\n\n所以我們可以不用額外做設定，直接 `git add .` 把東西加進去 git 倉庫，然後在 github 上面創一個私人的倉庫、按照教學把 github 倉庫跟本地倉庫連結，內容推上去就可以了。\n\n \n\n## Reference\n\n- [【學習筆記】如何使用 Hexo + GitHub Pages 架設個人網誌](https://hackmd.io/@Heidi-Liu/note-hexo-github#Hexo-%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE)：介紹如何建制、Hexo 常用的指令、如何發布到 Github 上面。\n- [建立自己Blog系列(三) Hexo next theme 介紹](https://isdaniel.github.io/hexo-blog-theme/)：有更詳細的介紹 Configure 區域對應的用途\n- [3分鐘完成HexoBlog主題Next設定](https://tiida54.github.io/2018/01/05/3%E5%88%86%E9%90%98%E5%AE%8C%E6%88%90HexoBlog%E4%B8%BB%E9%A1%8CNext%E8%A8%AD%E5%AE%9A/)：講解到 `scheme` 的部份，但似乎版本有點舊，有些屬性沒找到。\n- [[教學]使用 GitHub Pages + Hexo 來架設個人部落格](https://ed521.github.io/2019/07/hexo-install/#gt-%E8%A8%AD%E5%AE%9A%E9%83%A8%E7%BD%B2%E8%87%B3-GitHub-%E7%9A%84%E8%B3%87%E8%A8%8A)：也是屬於從頭部屬 Hexo 並上傳 Github，但在 Github Page 的部份有更仔細的解釋。\n- [雲沐居: 最新 Hexo NexT v7.4.1 主題優化](https://zenreal.github.io/posts/44730/)：比較多是對文章內容格式有影響的介紹，像是用一些特殊的 block，螢光筆色這種。\n- [Hexo博客个性化配置](https://oscarcx.com/tech/hexo-customize.html#%E9%AD%94%E6%94%B9footer)：`Next` 主題的進階修改，偏向一些部落格整體的小工具，如閱讀進度條、音樂播放器...。\n- [hexo(Next主题)修改文字大小](https://blog.csdn.net/dpdpdppp/article/details/102387532)\n- 主題: [Next](https://theme-next.js.org/next-8-8-2-released/#%F0%9F%9B%A0-Improvements)\n- 主題: [Stun](https://github.com/liuyib/hexo-theme-stun/)"
    },
    {
        "metadata": {
            "title": "hexo-2-theme-Next",
            "date": "2022-01-26T13:33:05",
            "tags": [
                "hexo"
            ],
            "description": "更新 Next 主題與啟用 prismjs，並修改行中程式碼(inline code) 的 CSS 格式。",
            "aliases": [
                "/posts/2022-01-26-blog-2-theme-Next-update",
                "/posts/2022-01-26-blog-2-theme-Next-update.html"
            ]
        },
        "content": "## 主題版本更新\n\nNext 主題有在定期更新，每次更新後可能 config 的內容位置都可能有更動。\n\n[Next 在 v8.x 的版本中有給予建議](https://theme-next.js.org/docs/getting-started/configuration)，不要將個人的變更寫在 `theme/Next/_config.yml` 下面，這樣每次 config 有改版都要一個個更新，不一定能完美的 merge。\n\n我們可以在與 site config (配置 hexo 的設定檔) 同層級的地方，創建一個 `_config.[theme].yml` 的檔案，`theme` 帶入主題的名稱。這個檔案中的內容會覆蓋 `theme/[next]/_config.yml` 的內容。\n\n如果以 NexT 主題為例：我的 `theme` 底下主題名稱為 `next`，配置的客製化檔案名稱為 `_config.next.yml`。並且我只在裡面放有修改區塊的 config ，避免未來如果要升級，我還花功夫去找哪裡有變更。\n\n## PrismJs 的啟用\n\n這部分跟主題的版本有關，雖然我是在 2021 年底創建部落格的，但不曉得為何用到了很舊版的 Next，其 `_config` 沒有有關 Prismjs 在 codeblock 欄位底下的配置。\n\n後來發現這個問題之後進行版本更新，並遇到在兩個配置落差頗大的 `_config` 之間玩比對遊戲，因此體悟出了上述辦法的優勢。\n\n更新後，codeblock 裡面有如下配置:\n\n```yaml\ncodeblock:\n  theme:\n    light: default\n    dark: tomorrow-night\n  prism:\n    light: prism-tomorrow\n    dark: prism-tomorrow\n```\n\n並且 hexo 的 `_config` 要將 prismjs 開啟、highlight 關閉: \n\n```yaml\nhighlight:\n  enable: false\n  line_number: false\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: true\n  line_number: false\n  tab_replace: ''\n```\n\n## 修改行中程式碼的格式 (change inline code style)\n\n我不喜歡預設的 inline code 格式，覺得太灰、padding 太大。而且這些 code 不隸屬 prismjs 的主題規範，要從 CSS 下手! \n\n首先，我們可以透過右鍵檢查元素發現 inline code 也是隸屬於 `code` tag，就瞄準這部份研究，我尋找到的方法是直接去改 css 設定。\n\n在 `source\\_data\\styles.styl` 當中(沒有則創建!)，寫入設定：\n\n```stylus\ncode {\n  padding: 0.1em 0.25em;\n  overflow-wrap: break-word;\n  word-break: break-all;\n  color: #cf222e;\n  background: #fbf7f8;\n  border-radius: 0.2em;\n  font-size: 1em;\n  font-weight: lighter; // bolder\n}\n```\n\n字體顏色選擇跟 github keyword 相似的顏色 `#cf222e`，雖然這使得 inline code 變得紅字很惹眼，但等到看到受不了再來想其他改法吧。\n\n光寫入沒有用，還要把這個檔案引入 Next 的渲染過程中。在上述的 `_config.next.yml` 中添加一段：\n\n```yaml\ncustom_file_path:\n  style: source/_data/styles.styl\n```\n\n再嘗試 `hexo server` 之類的在本地 demo 一下，應該可以看到改動的內容了！\n\n---\n\n參考自：\n\n- [Hexo之Next主題代碼優化](https://www.cnblogs.com/LyShark/p/11834144.html)\n- [【Hexo】以 Next 主題為基礎，打造自己的樣式吧！](https://myiaj.github.io/2020/03/14/hexo-custom-style/)"
    },
    {
        "metadata": {
            "title": "hexo-3-speedup-Next",
            "date": "2022-01-26T13:43:09",
            "tags": [
                "hexo"
            ],
            "description": "減少 Next 主題的載入時間!! 修改 Next 主題載入動畫時間長度，改變主題字體並加速載入。",
            "aliases": [
                "/posts/2022-01-26-blog-3-speedup",
                "/posts/2022-01-26-blog-3-speedup.html"
            ]
        },
        "content": "**2022/01/30**：最近在優化 SEO，想讓 google 可以索引到網站。遲遲不知道問題出在哪裡，google 表示有安排了但還沒索引到。反正就各種搞行動裝置優化，好笑的是把字體設定回預設、把 icon 關掉，一下子行動版跟網頁板效能都變 99~100 了，真是有點嘲諷...。\n\n**2022/01/26** ：說實話，在改字體後還想要網站加速，突然覺得自己有點癡人說夢。改字體本來就會造成額外的負擔! 但還是基於個人的喜好依然想改，照樣記錄一下心路歷程! \n\n## 改變字體\n\n有關  `_config.next.yml` 與  `source\\_data\\styles.styl`  的配置參見前面的兩個章節！\n\n1. 在 `_config.next.yml` 中配置字體段落\n\n   ```yaml\n   font:\n     enable: true \n     host:\n     global:\n       external: false # 如果寫 true, 就可以不用考慮後面的第三步了。\n       family: 'Noto Serif SC'\n   ```\n\n2. 在`source\\_data\\variables.styl` 中設置環境變數，覆蓋原本的設定檔。\n\n   記得要整段 font 的段落都複製！舉例而言，如果只覆蓋了 `font-family-chinese` 與 `font-family-base` 兩個變數，疑似因為在 Next 原本檔案中有其它變數使用到 `font-family-base`，而他們只會記住舊的變數。這會導致畫面有部份（像是 side bar）更改字體，而有部份依然使用微軟正黑體。\n\n   ```stylus\n   $font-family-chinese      = 'Noto Serif TC', 'Microsoft YaHei'; \n   \n   $font-family-base         = $font-family-chinese, sans-serif;\n   $font-family-base         = get_font_family('global'), $font-family-chinese, sans-serif if get_font_family('global');\n   \n   $font-family-logo         = $font-family-base;\n   $font-family-logo         = get_font_family('title'), $font-family-base if get_font_family('title');\n   \n   $font-family-headings     = $font-family-base;\n   $font-family-headings     = get_font_family('headings'), $font-family-base if get_font_family('headings');\n   \n   $font-family-posts        = $font-family-base;\n   $font-family-posts        = get_font_family('posts'), $font-family-base if get_font_family('posts');\n   \n   $font-family-monospace    = consolas, Menlo, monospace, $font-family-chinese;\n   $font-family-monospace    = get_font_family('codes'), consolas, Menlo, monospace, $font-family-chinese if get_font_family('codes');\n   \n   ```\n\n接下來是第三步驟，主要是我發現改字體後的載入速度比使用原生的微軟正黑體慢了至少 0.5~1秒以上吧。我嘗試想加速字體載入的部份，會先寫建議使用的方法，再紀錄一下我嘗試的方法。\n\n```yaml\nfont:\n  global:\n    external: false\n    family: 'Noto Serif SC'\n```\n\n\n\n### 方法一：字體預載入\n\n來到 [google font api](https://fonts.google.com/noto/specimen/Noto+Serif+TC) ，我們選擇要的粗細(Regular) 之後，左邊會有個彈出視窗，教導我們怎麼在 Html 跟 CSS 中嵌入。\n\n> To embed a font, copy the code into the `<head>` of your html\n\n```html\n<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Noto+Serif+TC&display=fallback\" rel=\"stylesheet\">\n```\n\n可以用 Vscode 之類的在部落格資料夾中找到寫有 `<head>` 的模板，在我的版本 (V8.9) 中，這位於 `themes\\next\\layout\\_layout.njk`，直接在 `<head>` 中把上面那段落貼上，就完成了！\n\n由於我對網頁前端並不熟悉，不是很確定這是否為關鍵因素。但在我使用預設的 config `external:true` 並把 preload 註解掉之後，透過 [pagespeed](https://pagespeed.web.dev/) 測試，載入時間落差約有一秒左右。\n\n### 方法二：掛載在當前網域下 (不建議)\n\n在 `source\\_data\\styles.styl` 中添加字體的匯入：\n\n```stylus\n@font-face {\n  font-family: 'Noto Serif TC';\n  font-weight: 400;\n  font-style: normal;\n  font-display: fallback;\n  src: local('Noto Serif TC'), local('Noto-Serif-TC'),\n       url('/fonts/NotoSerifTC-Regular.otf');\n}\n```\n\n`font-display: fallback` 可以使網頁先使用預設字體（微軟正黑體）這種本身就存在於電腦中的字體，使內容可以先顯示。而背景會默默把設定的 Noto Serif TC 下載，事後置換。\n\n選擇掛在於子網域未必會比較好，因為完整的 otf 檔案高達 MB 級，儘管設置了字體置換，等到完整的載入字體也需要長達 10 秒的時間 (視網路速度吧)。而 google font api 本身有把字體切割成很多部份，讓網頁可以選擇載入有用到的部份字形即可，節省下載量。\n\n## 找出網頁的 Bug\n\n可以打開 chrome [開發人員工具](https://support.google.com/campaignmanager/answer/2828688?hl=zh-Hant) 中 \"Network\" 項目，並 ctrl+R  重新整理網頁。檢查一下都是哪些檔案拖垮了網站速度。我當時發現有一些找不到路徑的字體檔案、Hexo 在產生靜態頁面時有寫的 warning 都有影響，所以修到沒 bug 在推上網路很重要。務必確保網頁在載入的期間只有載入**需要的元件**，不需要花時間試誤。\n\n```\nWarning: Accessing non-existent property 'filename' of module exports inside circular dependency\n```\n\nGoogle 一番之後，參考[此篇文章](https://www.haoyizebo.com/posts/710984d0/) 發現是 `nib` 套件出了問題。我的解決方法沒有順著他的教學，先嘗試重新安裝 `hexo-renderer-stylus` 但並沒有用。添加 `\"resolutions\"` 的部分忘記有沒有嘗試過，或許還是失敗了吧。\n\n最終，我是在 `package-lock.json` 的 `nib` 套件下找到: \n\n```yaml\n\"stylus\":0.54.5\n```\n\n修改成\n\n```yaml\n\"stylus\": 0.54.8\n```\n\n`npm install` 之後參照輸出的資訊內容，先後下指令 `npm audit fix` 與 `npm audit fix --force` 解決了這個問題。\n\n## 修改 Next 主題的動畫時間 [不建議]\n\n由於不同版本的 Next 程式碼內容也可能有所不同，參考自: [Hexo NexT 主題修改動畫效果速度](https://blog.csdn.net/Domino_b/article/details/81704118)。\n\n1. 使用 Vscode 之類的編輯器在 Next 主題中尋找關鍵字 `duration`，它可能出現在很多 js 檔案中，有些預設是 200、有些是 500。\n2. 直接改數字，我先改成 100 之後大概看一下效果，網頁載入的速度明顯有提升! 可以先在 localhost 上測試。不敢貿然換成 0 的原因是不確定會不會因為某些元素來不及載入造成錯誤，反而拖到整體的時間。\n3. 稍微判讀一下程式變數，有些頗容易看出函式意義的可以改短一點，不怕會不會影響載入，例如: `registerSidebarTOC`函式應該是跟側邊欄位「文章目錄」、「本站摘要」之間切換的動畫吧，我會再把數字改小一點。\n\n反覆在 local 端測試會不會造成 Bug 或使用者體驗不佳，之後就可以部屬到 github page 上了。部屬之後可以到 [pagespeed](https://pagespeed.web.dev/) 測試一下表現如何，該網頁會給一些診斷建議，但我自己沒有前端經驗不太知道怎麼改，只是拿來測速度。目前的網頁測試在電腦版中大約有 85-89 分的成績。\n\n## 在 Next Config 中設置動畫選項\n\n在手動更改 duration 數值後依然不滿意的我繼續爬，發現其實 Next 主題在 config 中就已有一段設定了，可以**直接把動畫關掉**。即使想要保留動畫，`async` 也可考慮開起來，讓元素們非同步加載有機會讓 Loading 更快吧。之所以前一段去改 duration 列為不建議是因為，我不太確定修改間隔會不會對元素的加載產生一些問題，但還是記錄起來。\n\n值得一提的是，包括進場動畫其實都是可以改的! 在 Next 主題的 demo 頁面中有展示各個特效名稱對應的效果: https://theme-next.js.org/animate/ 。\n\n這邊是我已經改過的 yaml 部分: \n\n```yaml\nmotion:\n  enable: true\n  async: true\n  transition:\n    # All available transition variants: https://theme-next.js.org/animate/\n    post_block: fadeIn\n    post_header: fadeInUp \n    post_body: fadeIn\n    coll_header: fadeInLeft\n    # Only for Pisces | Gemini.\n    sidebar: fadeInUp\n```\n\n## Plugin : `hexo-filter-optimize`\n\n下載之後\n\n```sh\nnpm install hexo-filter-optimize\n```\n\n在 site config (hexo config) 中添加設定: 我會把 css 的 bundle 關掉，因為開啟來的時候有一點造成畫面跑版，看得不太舒服。\n\n```yaml\nfilter_optimize:\n  enable: true\n  # remove the surrounding comments in each of the bundled files\n  remove_comments: false\n  css:\n    # minify all css files\n    minify: true\n    # bundle loaded css files into one\n    bundle: false\n    # use a script block to load css elements dynamically\n    delivery: true\n    # make specific css content inline into the html page\n    #   - only support the full path\n    #   - default is ['css/main.css']\n    inlines:\n    excludes:\n  js:\n    # minify all js files\n    minify: true\n    # bundle loaded js files into one\n    bundle: true\n    excludes:\n  # set the priority of this plugin,\n  # lower means it will be executed first, default of Hexo is 10\n  priority: 12\n```\n\n使用 `hexo-filter-optimize` 之後，有機會讓分數提升，我在手機版面上的分數就從 55 提升到了 78 (雖然有點迷惑那個分數的意義)"
    },
    {
        "metadata": {
            "title": "hugo-redirect",
            "description": "學習使用 Config，用最小的設定了解 docsy",
            "date": "2024-05-03T23:59:59",
            "aliases": [
                "/2023-01-01-posts",
                "/2023-01-01-posts.html"
            ]
        },
        "content": "## redirect URL \n\n由於舊的部落格網址設計不佳，我希望做 URL redirection。\n\nHugo 提供了 `aliases` 可以重新導向網址。以這篇文章來說，`domainName/2023-01-01-posts` 或是`domainName/notes/hugo-redirect` 都會導向這份內容 。\n\n```yaml\naliases:\n- /2023-01-01-posts\n```"
    },
    {
        "metadata": {
            "title": "Inline-Specifier",
            "date": "2024-05-05T09:00:00",
            "description": "關於 C++ 的關鍵字 Inline",
            "categories": [
                "cpp"
            ]
        },
        "content": "## 什麼是 Inline\n在 C++ 中，inline 是一種優化的方式，透過在編譯期間將 Function call 替換成 Function body，以優化調用過程。\n\n## 關鍵字 inline 僅意味「向 Compiler 發出申請」\nProgrammer 可以明確的提出請求，或隱喻的提出。但不論哪種，編譯器可以拒絕這個申請，大部分過於複雜的函式都會被拒絕 inline:\n- 有 loop 的\n- 多數的 virtual function (等 Runtime 才確定哪個被喚醒)\n\n顯示與隱式的分別:\n- 顯式: 關鍵字 `inline` 是一種對 Compiler 發出的明確請求，但 Compiler 不一定會遵循。\n- 隱式: 有另一種暗示請求，就是把 function 實作寫在 class 定義裡面。這種通常是 member function，但 friend function 也可直接定義在 class 內，因此也可能被隱式宣告為 inline。\n\n```cpp\nclass Person {\npublic:\n\tint age() const { return theAge; } \n\t// an implicit inline request: age is  defined in a class efinition\nprivate:\n\tint theAge;\n};\n```\n\n[Template Specilization 遇到的 Multiple Definition](../template-specilization-and-multiple-definition)"
    },
    {
        "metadata": {
            "title": "linux-ssh",
            "description": "先前在 VS Code 的設定文章中有提及過 SSH 登入的設定，本篇以 Linux 的 SSH 登入開始介紹，並且提及 scp 與 sshfs 方便於多台 Linux 機器之前交換資料的模組。",
            "date": "2022-10-24T21:47:12",
            "categories": "Linux",
            "aliases": [
                "/posts/2022-10-24-linux-ssh",
                "/posts/2022-10-24-linux-ssh.html"
            ]
        },
        "content": "先前在 VS Code 的設定文章中有提及過 SSH 登入的設定，本篇以 Linux 的 SSH 登入開始介紹，並且提及 `scp`, `sshfs` 兩個基於 SSH 連線，方便於多台 Linux 機器之前交換資料的模組。\n\n## 使用 SSH 登入\n\n1. 首先，本地 (local) 的電腦需要有 SSH key，\n\n   ```\n   ssh-keygen\n   ```\n\n   首先它會問 ssh 存放的位置，預設是 `~/.ssh` 下面。密碼如果直接按 Enter 相當取用不需要用密碼，可自行斟酌。\n\n   資料夾中 `id_rsa.pub` 是公鑰、`id_rsa` 是私鑰。\n\n2. 取得遠端 (remote) 電腦的 IP。登入遠端機器之後，使用 `ipconfig` 或 `ifconfig` 通常可以找到，如果兩者都無法，可以用指令 `cat /etc/hosts` 查找。\n\n### 把公鑰放到遠端機器上\n\n先說簡單的方法，使用 `ssh-copy-id`\n\n```\nssh-copy-id <remote id> \n```\n\n會需要輸入一次密碼，指令會把 public key 放到遠端機器上設定好。參考：[ssh-copy-id](https://dywang.csie.cyut.edu.tw/dywang/security/node85.html)。\n\n另一種是手動方法，編號接續前面的 Step\n\n3. 在 Linux 上可用 `nano`, `vim` 之類的文字編輯器，在本地打開 `~/.ssh/id_rsa.pub`，複製內容。\n\n4. 把公鑰 (public key) 放到遠端電腦的  `~/.ssh/authorized_keys` 裡面。\n\n5. 從本地端使用 ssh 連線過去，嘗試是否成功！\n\n   ```bash\n   ssh username@IP -p port\n   ```\n\n使用 SSH 可以免去每次都要輸入密碼的環節，像是 mobaxterm 這種工具雖然有記住密碼的功能，有鑑於之前曾發生忘記 mobaxterm 密碼的慘劇，讓我後來都改用 SSH 的方式 。當然 `.ssh` 如果有設密碼一樣可能面臨相同的困擾，但 `ssh` 在 linux 上可用的範圍更為廣泛，算是個好處吧。\n\n## 給予遠端 IP 別名\n\n像是在用 docker, kubernetes 一次使用多台機器的時候，如果每一台的 IP 都不同，也不怎麼連續。有時候又會需要登入每一台做些設定，這時如果能給每一台機器的 IP 都設其他代稱，可以方便許多。以下會先說名 ssh 部份的作法，後面提及使用 docker 的經驗！\n\n### 設置 .ssh/config\n\n位置在 `~/.ssh/config` 下，\n\n```bash\nHost            remoete_machine \t# 代稱\nHostname        192.168.0.1        \t# ip address\nPort            22                \t\nUser            jonny                # user name\nidentityfile    ~/.ssh/id_rsa   \t # private key 位置 \n```\n\n這樣下次就可以直接用這邊設定的內容連線！但如果前面在產生 ssh key 的時候有設密碼，則每次連線會需要打那個密碼！\n\n```bash\nssh remoete_machine\n```\n\n### 在網域上尋找機器\n\n我曾遇到過需要自己找 IP 的情況....，要在網域上尋找機器，可使用使用 nmap，用法可參考文章最後的參考資料。\n\n```bash\nsudo apt install nmap\nsudo nmap -sn 192.168.1.1-100\n```\n\n### 改變 IP address 的 hostname\n\n這是另外一種作法，在使用 docker 管理多台 Raspberry Pi 時曾用此方法：修改檔案 `/etc/hosts` 。把 IP 位置改成自訂的 hostname，例如：\n\n```\n192.168.1.181         docker1\n192.168.1.182         docker2\n192.168.1.183         docker3\n192.168.1.184         docker4\n```\n\n其實前面提到的 `ssh-copy-id`，如果在這一部先設好每一個 IP，用腳本跑 `ssh-copy-id` 有機會輕鬆的多。\n\n## scp\n\n透過 SSH 執行 Copy ，`scp` 之後第一個位置是 source、第二個位置是 destination\n\n```bash\n# local to remote \nscp <local path> user@192.168.0.1:<remote path>\n# remote to local\nscp user@192.168.0.1:<remote path> <local path>\n```\n\n複製目錄也跟原始的 `cp` 相似，加上 `-r` 參數：\n\n```bash\nscp -r user@192.168.0.1:<remote path> <local path>\n```\n\n要從同台機器上，複製多個資料夾的內容，則在冒號後面把路徑寫在一起：\n\n```bash\n# 正確作法\nscp -r user@192.168.0.1:\"dir1 dir2 dir3\" <local path>\n\n# 會複製兩次! （如果有設密碼就要打兩次）\nscp -r user@192.168.0.1:dir1 user@192.168.0.1:dir2 <local path>\n```\n\n## sshfs\n\n需要注意，如果不是 root 用戶，本地位置**目錄**的**擁有者**必須為使用者自己（不能把檔案從遠端 copy 到這台電腦中，別的 user 所屬的資料夾的概念）。如果遠端機器的 ssh port 不是預設的 22 （是透過 router 設定 port forwarding 之類的），要透過 `-p <port>` 標明連哪個 port，否則會連線不進去。\n\n```bash\nsshfs <remote location> <local location>\nsshfs username@hostname:/path/to/folder /path/to/local/folder\nsshfs -p <remote port> username@hostname:/path/to/folder /path/to/local/folder\n# example\nsshfs -p 1000 pi@0.0.0.100:/share_files /accept_file\n```\n\n這個舉動的意思是：把遠端機器(`0.0.0.100`) 上的 `share_files` 資料夾『掛載 (mount)』到我的機器上的 `accept_file` 資料夾！因為是用 mount 的，所以當遠端機器的 `share_files` 內容有更新，我這邊的 `accept_file` 也會同步更新！\n\n而如果希望解除綁定資料夾的狀態，可以參考下面連結的論壇，用 `fusermount -u /path/to/local/folder` 解除本地資料夾與遠端的連結。\n\n## 參考資料\n\n- [Configuring an SSH login without password](https://www.ibm.com/support/pages/configuring-ssh-login-without-password)\n\n- [Nmap 網路診斷工具基本使用技巧與教學](https://blog.gtwang.org/linux/nmap-command-examples-tutorials/)\n\n- [介紹好用工具： SSH Filesystem (簡單好用的 SSH 檔案系統)](https://blog.miniasp.com/post/2013/11/30/Useful-tool-SSHFS-SSH-Filesystem)\n\n- [How to Run a Raspberry Pi Cluster with Docker Swarm](https://howchoo.com/g/njy4zdm3mwy/how-to-run-a-raspberry-pi-cluster-with-docker-swarm)\n\n- [Linux 的 scp 指令用法教學與範例：遠端加密複製檔案與目錄](https://blog.gtwang.org/linux/linux-scp-command-tutorial-examples/)\n\n- [介紹好用工具： SSH Filesystem (簡單好用的 SSH 檔案系統)](https://blog.miniasp.com/post/2013/11/30/Useful-tool-SSHFS-SSH-Filesystem)\n- [How to copy files from one machine to another using ssh](https://unix.stackexchange.com/questions/106480/how-to-copy-files-from-one-machine-to-another-using-ssh#answer-106485)\n- [[Linux] 在 CentOS 上使用 sshfs 來掛載 SSH server 上的檔案系統](https://ephrain.net/linux-%E5%9C%A8-centos-%E4%B8%8A%E4%BD%BF%E7%94%A8-sshfs-%E4%BE%86%E6%8E%9B%E8%BC%89-ssh-server-%E4%B8%8A%E7%9A%84%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1/)"
    },
    {
        "metadata": {
            "title": "pickle-advance",
            "date": "2022-01-17T20:56:22",
            "categories": "Python",
            "description": "繼前一篇文章進一步探討 Pickle 模組：理解 PEP3155談論到的 Qualified name、與帶有裝飾器(decorator) 的函式遇到 Can't pickle local object 應如何解決。",
            "aliases": [
                "/posts/2022-01-17-pickle-advance",
                "/posts/2022-01-17-pickle-advance.html"
            ]
        },
        "content": "## PEP 3155 Qualified name\n\n有關 Fully Qualified Name 的部份我是第一次看到...，嘗試閱讀 PEP 內容，不是很確定閱讀理解是否正確，若有錯誤歡迎指教！\n\n這個 PEP 議題是添加一個 `__qualname__` 屬性在函式跟類別中。對於 Top-Level 的函式與類別，這個屬性等同於 `__name__`，而對於巢狀的類別跟巢狀函式，`__qualname__` 屬性 dotted name 呈現，代表從 Top-Level 算起，該物件的層級位置。`repr()` 跟 `str()` 作用於類別與函式上時，也被修改成使用 `__qualname__`  而非 `__name__`。\n\ndotted name 表示從一個模組的 global 區域到該類別、函式或方法的路徑。\n\n```python\nclass C:\n    class D:\n        def meth(self):\n            pass\n\nIn [2]: C.__qualname__\nOut[2]: 'C'\n\nIn [3]: C.D.__qualname__\nOut[3]: 'C.D'\n\nIn [4]: C.D.__name__\nOut[4]: 'D'\n    \nIn [5]: C.D.meth.__qualname__\nOut[5]: 'C.D.meth'\n```\n\n而且對於被 `import` 的模組是不存在 `__qualname__` 屬性的，他們只有 `__name__`屬性，表達的是他的 Fully Qualified Name：該模組到其頂層父模組之間的層級關係：\n\n```python\nimport email.mime.text\nemail.mime.text.__name__\n```\n\n\n\n## 情境探討: 有裝飾器的函式無法被 Pickle\n\n問題來源[自此網站](https://blog.csdn.net/qq_39314099/article/details/83822593)，我們可以嘗試用閱讀完官方文件後的邏輯來解釋這個問題。因為覺得程式繁瑣，所以大概照著意思稍微改寫了一下，博主寫了一個名為 `haha` 的函式，會印出 `hello XXX`，並為它添加了計時裝飾器。雖然沒有明確的說怎麼存檔出了錯，但根據引發的 Error 我大致假設是嘗試存 `haha` 這個函式。\n\n```python\nimport time, pickle\nfrom functools import wraps\n\ndef timer(mth, *args,**kwargs):    \n    # @wraps(mth)\n    def wrapper(*args,**kwargs):\n        st = time.time()\n        res = mth(*args,**kwargs)\n        et = time.time()\n        print(f\"Spend {float(et-st)} sec.\")\n        return res\n    return wrapper\n\n@timer\ndef haha(name=None):\n    print(f\"Hello {name}\")\n\nwith open(\"function.pkl\", 'wb') as f:\n    print(\"name of haha function is:\", haha)\n    pickle.dump(haha, f)\n```\n\n在試圖存下這個函式時發生了問題：`AttributeError: Can't pickle local object 'timer.<locals>.wrapper'`。而樓主表示只要給裝飾器裡面裝上 `warp`，問題就解決了。`warp`應該擺放的位置已經寫在程式裡面了，可以試著註解與取消註解看看函式的名稱的不同。\n\n- 沒有 `warp` 的情況：`<function timer.<locals>.wrapper at 0x000001EBECA588B8>`\n- 有 `warp` 的情況：`<function haha at 0x000001BF76B188B8>`\n\n所以追根究底，這個問題的癥結點在於包上裝飾器後，若沒有使用 `functools.wraps` 讓裝飾後的函式名稱仍保持原樣，該函式的名稱會變成裝飾器內部函式 `wrapper` 的名稱。而由於 `wrapper` 不是一個 top-level 的函式，而是隸屬 `timer` 函式下的 `<locals>`，因此 Pickle 在試圖存取時直接因為名稱不符合 Pickable 原則而引發了錯誤。\n\n而且決方法僅僅是讓裝飾後的函式保留原本的名稱，一樣叫做 `haha`，Pickle 發現這個名稱存在於 Top-Level 就把他記下來。但實際上他記得的也只有名稱，Unpickle 的時候如果沒有保留定義 `haha` 的函式、或是 `haha` 的內容和 Pickle 時不一樣，執行起來仍會是不同的內容！\n\n## 個人見解\n\nPickle 是刻意設計不儲存程式碼，對函式與類別都以 name reference 的方式保存的。因此想要透過 pickle 來「永久的」存下函式與類別是不可能的，乍聽起來很不方便。但換個角度或許該想的是：\n\n- 什麼東西是應該被永久保存的呢？應該是資料。\n\n- 資料應該以何種形式存在呢？應該是實例。\n\n- 所以函式、類別是什麼？我想是一個流程、或是一個抽象的敘述。\n\n  理論上，如果有一些變動性的、Runtime 才決定的資料也應該是外部傳入，如果是內部所需要的資料也跟外界無關，作為 local 變數定義在程式碼中就好。\n\n這樣思考起來，好像也能夠明白為何函式與類別不會把程式碼存下來。\n\n但如果，需要函式有一點「記憶力」呢？例如，在執行 Min-max 正規化時，希望函式能夠記住第一次正規化的上下界屬性，後面都直接帶入就好，不用每次都傳入上下界；或是希望把這組正規化參數記下來，但不希望是把 min ＆ max 倆組分別記下來、怕資訊太零散。\n\n這種時候，或許可以考慮使用 Callable Object。定義一個 Class 並實踐 `__call__` 方法，把正規化行為定義在裡面，而需要記憶的屬性紀錄在實例裡面，像是 `self.mins`, `self.maxs`… ，在儲存的時候直接把這個 normalizer 存下來即可。\n\n```python\ndef norm(arr, mins, maxs):\n    return (arr-mins)/(maxs-mins)\n\nclass Normalizer:\n    def __init__(self, mins, maxs):\n        self.mins = mins \n        self.maxs = maxs \n        \n    def __call__(self, arr):\n        return (arr-self.mins)/(self.maxs-self.mins)\n        \n# in some main process.... \nif __name__==\"__main__\":\n    for data in datalist:\n        mins, maxs = data.min(), data.max()\n        data = norm(data, mins, maxs)\n        \n        # 1. 透過 function 達成\n        normalizer = lambda arr: norm(arr, mins, maxs)\n        def normalizer(arr): # OR do this... \n            return norm(arr, mins, maxs)\n        validation_data = normalizer(validation_data)\n        \n        joblib.dump(normalizer, \"normalizer.pkl\") # 決對會出錯.. \n        \n        # 2. 透過 callable object 達成 \n        normalizer = Normalizer(mins, maxs)\n        data = normalizer(data)\n        validation_data = normalizer(validation_data)\n        joblib.dump(normalizer, \"normalizer.pkl\")     \n```"
    },
    {
        "metadata": {
            "title": "pickle-basic",
            "date": "2022-01-17T19:46:50",
            "categories": "Python",
            "description": "研究 Python 官方文件中的 Pickle 模組，探討常發生的 lambda PicklingError 問題。",
            "aliases": [
                "/posts/2022-01-17-pickle-basic",
                "/posts/2022-01-17-pickle-basic.html"
            ]
        },
        "content": "Pickle 是 Python 裡面物件儲存的原生套件，延伸的套件有不少，我個人就慣用 `joblib`。\n\nPickle 直接翻譯是醃漬的意思，這樣說起來很怪，所以以下我可能會用「打包、存檔」之類的作為他的中文敘述，unpicke 直翻有拆開的意思，大陸那邊會有人稱為酸洗，同樣覺得很怪異，以下可能會用「復原、讀取、解包」之類的詞來敘述。若撰寫的當下覺得替代的中文會使意義變得模糊，則會直接採用原本的 pickle 與 unpickle 作為敘述。\n\n## [什麼物件可以被 Pickle / Unpickle][what can be pickled and unpickled]\n\n- 基本型態的數值：None、布林值、整數、浮點數、複數\n- 基本型態的文字類：字串、位元、位元陣列\n- 基本的可迭代類型：tuple、list、set、字典(dictionaries)，若其內含物件都是 picklable 物件的化就可以。\n- 在 Top Level 被定義的\n  - 函式 (function) ，只接受用 `def` 定義的，用 `lambda` 定義的一樣是 Unpicklable。 **[以 name reference 形式儲存]**\n  - 類別 **[以 name reference 形式儲存]**\n  - 類別的實例：其 `__dict__` 或 `__getstat__()`的回傳必須是 pickable 的。\n\n企圖將 unpickle 物件存下來會引發[`PicklingError`](https://docs.python.org/3/library/pickle.html#pickle.PicklingError) 例外，嘗試 pickle 一個高度遞迴的資料結構可能會超過最高遞迴深度而引發 [`RecursionError`](https://docs.python.org/3/library/exceptions.html#RecursionError)（對於這個問題可以透過設置  [`sys.setrecursionlimit()`](https://docs.python.org/3/library/sys.html#sys.setrecursionlimit) 解決）\n\n## Pickle Function/Class\n\n不管是 Built-in function 或使用者自訂的函式，都是透過 function 自身的完整名稱 (“fully qualified” name reference) 將 function pickle 下來，而不是透過值 pickle。這是為何 lambda 函數沒辦法被 pickle ，因為所有的 lambda 函數的名稱都一樣叫做 `<lambda>`。Python 官方文件的內容如下：\n\n> Note that functions (built-in and user-defined) are pickled by “fully qualified” name reference, not by value. [2](https://docs.python.org/3/library/pickle.html#id8) This means that only the function name is pickled, along with the name of the module the function is defined in. Neither the function’s code, nor any of its function attributes are pickled. Thus the defining module must be importable in the unpickling environment, and the module must contain the named object, otherwise an exception will be raised. [3](https://docs.python.org/3/library/pickle.html#id9)\n\n有關 [PEP 3155][PEP 3155] 的 \"fully qualified\" name reference 在之後會稍微提到。\n\n```python\ndef function_example():\n    print(\"Hi\")\n\nlambda_example = lambda : print(\"this is lambda\")\n\nIn [5]: lambda_example.__name__ # 所有的 lambda 函式名稱都是 lambda \nOut[5]: '<lambda>'\n\nIn [6]: function_example.__name__ # function 的名稱是自己的\nOut[6]: 'function_example'\n```\n\n此外，被 Pickle 的內容實際只有名稱，而沒有程式碼。因此在 Unpickle 的環境如果沒有在對應的位置定義對應的函式，是沒有辦法被 Unpickle 的! 我們可以先嘗試在一個檔案中定義函式並把他存下來：\n\n```python\nimport pickle \ndef bar():\n    print(\"lalalala~~~~\")\n\nwith open(\"function.pkl\", 'wb') as f:\n    pickle.dump(bar, f)\n```\n\n然後在一個全新、沒有定義過 `bar` 函式的環境中，試圖將其復原。會發現引發了 `AttributeError`\n\n```python\nimport pickle \nwith open(\"function.pkl\", \"rb\") as f:\n    bar = pickle.load(f)\n# AttributeError: Can't get attribute 'bar' on <module '__main__'>\n```\n\n類別也一樣，被儲存的實際上只有名稱而沒有程式碼，若在 Unpickle 的環境中沒有定義該類別，一樣會引發 `AttributeError`。\n\n## [Pickle Class Instance](https://docs.python.org/3/library/pickle.html#pickling-class-instances)\n\n與 Function 相同，儲存類別的方式也是透過 named reference 儲存(classes are pickled by named reference)。\n\n雖然 Pickle 可以儲存類別的實例，但實際上他**不會儲存任何的類別程式碼、類別屬性**。準確的來說，他存的是實例的「屬性」，用 Python 來敘述 pickle 的 `dump` 與 `load` 動作如下：\n\n```python\ndef save(obj):\n    return (obj.__class__, obj.__dict__)\n\ndef load(cls, attributes):\n    obj = cls.__new__(cls)\n    obj.__dict__.update(attributes)\n    return obj\n```\n\n用實際的例子演示一下儲存跟復原的邏輯：\n\n```python\nclass Foo:\n    attr = 'A class attribute'\n    def __init__(self, ):\n        self.inst_arr = \"Instance attribute!\"\n        self.fake_attr = \"This is fake\"\n        \nfoo = Foo()\npickled_info = save(foo) # (__main__.Foo, {'inst_arr': 'Instance attribute!'})\nrecover_foo = load(*pickled_info)\n```\n\n如果我們想要復原存下來的實例，程式碼中必須保留該類別的定義，否則會引發錯誤。上面僅僅是用程式說明邏輯，現在實際套用 pickle 套件\n\n```python\nimport pickle\n        \nfoo = Foo()\nwith open(\"test.pkl\", \"wb\") as f:\n    pickle.dump(foo, f)\n\nwith open(\"test.pkl\", \"rb\") as f:\n    my_foo = pickle.load(f)\nprint(my_foo.inst_arr)\nprint(my_foo.attr)\n```\n\n但如果用別份程式碼定義把實例從 pkl 中復原，而該份程式碼中沒有類別 `Foo`，就會引發錯誤：\n\n```python\nimport pickle\nwith open(\"test.pkl\", \"rb\") as f:\n    my_foo = pickle.load(f)\n# AttributeError: Can't get attribute 'Foo' on <module '__main__'>\n```\n\n- `pickle.dump` ：記住該實例所使用類別的名字 (named reference)、與其實例屬性\n- `pickle.load`：試圖在程式中尋找記住的類別名字，在不初始化的情況(不調用 `__init__`)下，默默的創建一個實例，並對所有的實例屬性套用 `pkl` 中所記憶的數值。\n\n如果 pickle 沒辦法在程式中尋找到該 named reference 就會引發例外，不是定義在 Top Level 的函式、類別會沒有辦法透過 named reference 取得；而所有的 lambda function 都共享同一個 name reference , `<lambda>`，代表在復原的時候根本沒辦法找到存到的是哪個 lambda 函式，所以在試圖 dump 的時候就先被排除了。\n\n```\nPicklingError: Can't pickle <function <lambda> at 0x00000213F8790948>: attribute lookup <lambda> on __main__ failed\n```\n\n### 刻意的設計\n\n不儲存有關類別的屬性、類別的程式碼是故意的設計，這樣做的好處是：如果在 v1 版本中我們儲存了某個實例，後來發現該實例對應的類別有錯、或是對類別擴增了方法而修改程式變成 v2 版本。我們依然可以在 v2 版本中讀取曾經存下來的實例，即使他是在前面版本 (v1) 中存下來的。\n\n```python\n# V1\nimport pickle \nclass Dog:\n    def __init__(self, legs):\n        self.legs = 4\n\ndog = Dog(6)\nwith open(\"test.pkl\", 'wb') as f:\n    pickle.dump(dog, f)\n```\n\n```python\n# V2\nimport pickle \nclass Dog:\n    def __init__(self, legs):\n        self.legs = 4\n        \n    def voice(self, ):\n        print(\"woof! woof! woof!\")\n\nwith open('test.pkl', 'rb') as f:\n    dog = pickle.load(f)\n\ndog.voice() # can run! \n```\n\n### 永久保存物件的版本\n\n如果們希望這是一個  long-lived 的物件，可以看到不同版本的類別，或許可以考慮在裡面放置版本號碼，以便透過類別的 `__setstate()__` 方法做適當的轉換。(官方文件裡面這樣寫，但我不是很懂要怎麼實踐)\n\n## 改變 Pickle 時的預設行為\n\nPickle 實例的時候，如果該實例的類別有設定下列方法，會改變 Pickle 時的預設舉動\n\n### 模組方法\n\n#### `object.__getnewargs_ex__()`\n\n在協定2與3中，實踐了此方法的類別可以在 unpickling 的時候將寫在 `__getnewargs_ex__` 的參數傳遞到 `__new__()` 裡面以建構物件。此方法必須回傳一對 tuple：`(args, kwargs)`，其中 `args` 是一個 tuple 包含著位置參數 (positional arguments)、`kwargs` 是一個字典包含關鍵字參數。\n\n#### `object.__getstate__()`\n\n類別可以可以決定屬於它們的實例要如何被打包，如果類別定義了此方法，pickle 時會直接呼叫此方法，用它的回傳作為實例所存下來的內容。而不是一般使用實例 pickle 的預設方式：使用 `__dict__` 作為存下的內容。\n\n#### `object.__setstate__(state)`\n\n若類別有定義此方法，Unpickle 的時候就會將得到的 state 傳入此方法。如果類別有定義此方法，則 state 物件不限定要是字典，因為在復原物件的時候 `__setstate__` 自己有一套規則了！\n\n但如果沒有實踐此方法，被存下來的 state (pickled state) 必須是字典的形式，這樣才能把它指派給新的(復原的) 實例的字典。大概有點像下面這種感覺吧：\n\n```python\nsaved_pkl = { arg1:val1, arg2:val2... }\nnew_obj.__dict__ = saved_pkl\n```\n\n關於 `__getstate__` 與 `__setstate__` 方法，可以參考  [Handling Stateful Objects](https://docs.python.org/3/library/pickle.html#pickle-state) 有更多資訊。\n\n### 處理擁有狀態的物件 (Handling Stateful Objects)\n\n這個例子將展示如何 modify 類別的 pickle 行為：`TextReader` 類別打開一個文字檔，當 `readline` 被呼叫的時候會回傳行數以及該行內容。如果 `TextReader` 實例被打包，除了文件物件(file object) 之外的屬性都可以被儲存。當實例復原時(unpickle)，檔案會被重新開啟，並且從上次最後讀取的位置繼續。這樣的功能就是透過 `__setstate__()` 和 `__getstate__()` 方法達成的，如果不實做這兩個方法，在嘗試 `dump` 的時候就會引發例外\n\n```\nTypeError: cannot serialize '_io.TextIOWrapper' object\n```\n\n這個類別在實做的時候做了幾件事：\n\n- `__getstate__()`：先將物件的 `__dict__` 屬性複製，並將沒辦法 pickle 的 IO 物件移除，回傳剩下的屬性字典(state)。\n- `__setstate__()`：\n  1. 將獲得的 state 更新進入新實例的 `__dict__` 屬性裡面\n  2. 根據已經復原的 `self.fileName`屬性，打開文字檔案。\n  3. 根據已經復原 `self.lineno` 屬性，將 `file` 的狀態讀到上次結束時的行數（把 file 復原到上次結束的狀態，因為他不能直接被 pickle）\n  4. 把已復原的 `file` 指派給實例的 `self.file` 屬性。\n\n如此一來，`TextReader` 的實例雖然實際上並沒有每個屬性都真正被 pickle 下來，但復原的時候卻彷彿回到上次剛結束的狀態繼續，達到儲存實例狀態的目的。\n\n```python\nclass TextReader:\n    def __init__(self, filename):\n        self.filename = filename\n        self.file = open(filename)\n        self.lineno = 0\n\n    def readline(self):\n        self.lineno += 1\n        line = self.file.readline()\n        if not line:\n            return None\n        if line.endswith('\\n'):\n            line = line[:-1]\n        return \"%i: %s\" % (self.lineno, line)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        del state['file']\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        file = open(self.filename)\n        for _ in range(self.lineno):\n            file.readline()\n        self.file = file\n```\n\n```python\nreader = TextReader(\"hello.txt\")\nreader.readline()\nreader.readline()\n\nnew_reader = pickle.loads(pickle.dumps(reader))\nnew_reader.readline()\n```\n\n\n\n\n\n[what can be pickled and unpickled]:<https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled>\n[PEP 3155]:<https://www.python.org/dev/peps/pep-3155/> \"Qualified name for classes and functions\""
    },
    {
        "metadata": {
            "title": "pyqt5-benefit-for-QStandardItemModel",
            "date": "2024-05-23T23:05:00",
            "description": "為何要使用 QStandardItemModel，而不繼承 QAbstractItemModel?",
            "categories": [
                "Python"
            ]
        },
        "content": "`QStandardItemModel` 繼承 [QAbstractItemModel](https://doc.qt.io/qt-6/qabstractitemmodel.html) ，如果想 implement 一個 Model，繼承 `QStandardItemModel` 會方便很多。\n\n接下來會以一個簡單的例子說明，過於簡單的資料結構繼承 `QAbstractItemModel` 可能有哪些困擾。\n## Quick Example\n假設手上的資料是 一個 2 rows x 3 columns Table，表格內容都是 True/False\n### 使用 `QAbstractItemModel` \n繼承 `QAbstractItemModel` 需要實作以下內容\n1. 提供儲存的資料結構: 以一個 2D list 儲存\n2. 由於儲存的結構是自己提供的，有些 function 要重新設計，而有些本就是 pure virtual function\n\t- `setData()`,  `data()`: 存在哪、怎麼拿。\n\t- `rowCount()`,  `columnCount()`: 同上，因為資料結構是自己的，數量也要自己算。\n\n```python\nclass MyModel(QAbstractTableModel):\n    def __init__(self, data):\n        super(MyModel, self).__init__()\n        self._data = data\n\n    def rowCount(self, parent=None):\n        return len(self._data)\n\n    def columnCount(self, parent=None):\n        return len(self._data[0])\n\n    def data(self, index, role=Qt.DisplayRole):\n        if role == Qt.DisplayRole:\n            return self._data[index.row()][index.column()]\n\n    def setData(self, index, value, role=Qt.EditRole):\n        if role == Qt.EditRole:\n            self._data[index.row()][index.column()] = value\n            self.dataChanged.emit(index, index, [Qt.EditRole])\n            return True\n        return False\n```\n\n### 使用 `QStandardItemModel`\n直接使用 Model，透過創建 `QStandardItem` 放資料進去。\n- `setCheckState(Qt.CheckState)` 相當於 `setData(Qt.CheckState, Qt.CheckStateRole`)，\n\n```python\nmodel = QStandardItemModel()\nfor i in range(2):\n\trow = []\n\tfor _ in range(3):\n\t\tit = QStandardItem(\"\")\n\t\t# Checked: True, Unchecked: False\n\t\tstatus = Qt.Checked if i==0 else Qt.Unchecked\n\t\tit.setCheckState(status)\n\t\trow.append(it)\n\tmodel.appendRow(row)\n```\n\n提取、重設資料也很簡單，不必實作 getter 跟 setter。\n\n在 `QAbstractItemModel` 當中，data 的 setter 跟 getter 都有一個參數 `role`。role 會影響資料存到哪裡、從哪提資料，如果 setter 跟 getter 給的 role 不同，就會拿不到想要的內容。\n對 model 設資料的 API 如下，需要給定 index 跟 role。\n```python\nsetData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole): bool\t\ndata(const QModelIndex &index, int role = Qt::DisplayRole): QVariant\n```\n\n而 QStandardItemModel 提供 API `item` 可以拿到 `QStandardItem`。在 `QStandardItem` 上又可以直接呼叫 `setCheckState`設值 -- 相當於對 model 以 `setData(index, checkState, Qt.CheckStateRole)`，可讀性更好，也更直觀。\n\n下面的範例說明怎麼透過 model 和 item 設值與取值，要做到這些都不需要實作 function 就能辦到。\n\n```python\nind = model.index(0, 0)\nrole = Qt.CheckStateRole\nprint(\"Get data for CheckStateRole\", model.data(ind, role))\nprint(\"Is same to call checkState() on item\", model.item(0,0).checkState())\n\nmodel.setData(ind, Qt.Unchecked, role)\nprint(\"After setCheckState\", model.data(ind, role))\nmodel.item(0,0).setCheckState( Qt.Checked)\nprint(\"Item also has equivalent function setCheckState, it can also modify data\", model.item(0,0).checkState())\n\n```\n## 總結\n`QStandardItemModel` 提供實用的介面，相當於對每一「格」的資料再封裝。\n在為 `QListView`/`QTableView`/`QTreeView` 做搭配的 model 時，一個簡單的方法判斷是否該採用\n- 資料的型態是簡單的 string, boolean 這種 build-in type 嗎? 是的話，`QStandardItemModel` 夠用。\n- 如果資料本身存在 customize class 裡面，本來就要實作 model 的 `data`/`setData` ，針對不同的 role 呼叫 class 不同的 function 給資料、存資料，就可以檢視 `QAbstractItemModel` 是否更好用。\n\n---"
    },
    {
        "metadata": {
            "title": "pyqt5-centeralignment-checkbox-in-qtableview",
            "date": "2024-05-18T12:30:00",
            "description": "讓 QTableView 顯示置中的 CheckBox",
            "categories": [
                "Python"
            ]
        },
        "content": "## 讓 Checkbox 置中\nTableVeiw 預設的 checkbox 沒辦法置中，解決方法有兩類\n1. 使用 Delegate \n2. 透過 setItemWidget 設 Layout，加 checkbox 元件\n\n## Example\n\n\n```python\nimport sys\nfrom PyQt5.QtWidgets import QApplication, QTableView, QCheckBox, QVBoxLayout, QWidget, QHBoxLayout\nfrom PyQt5.QtCore import Qt, QAbstractTableModel, QModelIndex \nfrom PyQt5.QtGui import QStandardItemModel\n\nclass CustomizeCheckBox(QWidget):\n    def __init__(self, parent, ftor ):\n        super().__init__(parent)\n        l = QHBoxLayout(self)\n        self.cb = QCheckBox(self)\n        l.addWidget(self.cb)\n        l.setAlignment(Qt.AlignCenter)\n        # You must set margins, otherwise checkbox style is strange.\n        l.setContentsMargins(0, 0, 0, 0)                \n        # m = l.contentsMargins()\n        # print(m.left(), m.right(), m.top(), m.bottom(), )\n        self.setLayout(l)\n        self.cb.stateChanged.connect(ftor)\n\n    def get_checkbox(self, ):\n        return self.cb\n\nclass CheckBoxTableModel(QStandardItemModel):\n    def __init__(self, rows, columns, parent=None):\n        super().__init__(rows, columns, parent)\n        self._rows = rows\n        self._columns = columns\n        self._data = [[False for _ in range(columns)] for _ in range(rows)]\n\n    def rowCount(self, parent=QModelIndex()):\n        return self._rows\n\n    def columnCount(self, parent=QModelIndex()):\n        return self._columns\n\n    def data(self, index, role=Qt.DisplayRole):\n        if not index.isValid():\n            return None\n        if role == Qt.DisplayRole or role == Qt.EditRole:\n            return \"\"\n        if role == Qt.UserRole:\n            return self._data[index.row()][index.column()]\n        return None\n\n    def setData(self, index, value, role=Qt.EditRole):\n\n        '''\n        setData set value to customize data struct when role is checkStateRole,\n        avoid data Qt.CheckStateRole modified in itemData. \n        It should be None, otherwise, checkbox will be shown.\n        '''\n        if index.isValid() and role == Qt.CheckStateRole:\n            self._data[index.row()][index.column()] = value\n            data = {Qt.DisplayRole: \"\", Qt.EditRole:\"\", Qt.UserRole:value}\n            print(data)\n            self.setItemData(index, data)\n            \n            self.dataChanged.emit(index, index, [Qt.CheckStateRole])\n            return True\n        return False\n    \n    # def flags(self, index):\n    #     return Qt.ItemIsEditable | Qt.ItemIsEnabled\n\n\nclass CheckBoxTableView(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.initUI()\n        self.model.dataChanged.connect(self.on_item_changed)\n    def initUI(self):\n        layout = QVBoxLayout(self)\n\n        self.tableView = QTableView(self)\n        self.model = CheckBoxTableModel(3, 4) \n        self.tableView.setModel(self.model)\n\n        for row in range(3):\n            for column in range(4):\n                index = self.model.index(row, column)\n                # Method 1\n                ftor = self.getCheckBoxHandler(index)\n                w = CustomizeCheckBox(self, ftor)\n                self.tableView.setIndexWidget(index, w)\n                # Method 2: Add checkbox directly, it will not cause starange layout.\n                # cb = QCheckBox(self)\n                # self.tableView.setIndexWidget(index, cb)\n\n\n        layout.addWidget(self.tableView)\n        self.setLayout(layout)\n\n        self.setGeometry(100, 100, 400, 200)\n        self.setWindowTitle('QTableView with QCheckBox')\n        self.show()\n    \n    def on_item_changed(self, item):\n        if type(item) == QModelIndex:\n            # val  = self.model.data(item, Qt.CheckStateRole)\n            val  = self.model.data(item, Qt.UserRole)\n        else:\n            val = self.model.data(item.index(), Qt.CheckStateRole)\n        print(\"Current data is,\", val)\n       \n    def getCheckBoxHandler(self, index):\n        def handler(state):\n            self.model.setData(index, state , Qt.CheckStateRole)\n\n        return handler\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    mainWin = CheckBoxTableView()\n    sys.exit(app.exec_())\n\n\n```"
    },
    {
        "metadata": {
            "title": "pyqt5-model-view-framework",
            "date": "2024-05-23T22:00:00",
            "description": "Model View Framework 的介紹，這跟 MVC 有何不同?",
            "categories": [
                "Python"
            ]
        },
        "content": "## Model-View-Controller\nMVC (model-view-controller) 是一種 design pattern，圖為 First Head Design Pattern 的範例。傳統的 MVC 架構如下\n- Model: 掌管業務邏輯，會是這個架構中唯一與 Database 交互的 component. \n- View: 透過 Controller 得到 Model 的資料，呈現在 UI 上。\n- Controller: 轉換 User Input 成 Model 應該採取的動作，讓 Model 採取動作、並拿新的資料更新 View。\n![First Head-MVC](https://www.oreilly.com/api/v2/epubs/9780596516680/files/httpatomoreillycomsourceoreillyimages2242349.png.jpg)\n\n## Model/View Framework\nQT 簡化了這三者的關係，當 View 跟 Controller 結合，就成為 Model/View architecture。這種架構更簡單，且依然切分 Data / UI ，甚至得以讓同一個 Model 直接搭配不同的 View，無須改變底層資料結構。\n\n而為了彈性的處理 User Input，QT 導入了 [*delegate*](https://doc.qt.io/qt-6/qitemdelegate.html) 的概念。在 QT 當中，delegate 負責處理編輯 (edit) 跟渲染 (render)，透過 customize delegate，更可以改變渲染的外觀，與存資料到 Model 的型式。\n\n## Models \n所有的 item models 都繼承  [QAbstractItemModel](https://doc.qt.io/qt-6/qabstractitemmodel.html) ，資料本身不一定要存在 model class，可以是外部的 database ，或其他自定義的 class。\n\n要客製化 model，建議從  [QAbstractListModel](https://doc.qt.io/qt-6/qabstractlistmodel.html),  [QAbstractTableModel](https://doc.qt.io/qt-6/qabstracttablemodel.html) 甚至 [QStandardItemModel](https://doc.qt.io/qt-6/qstandarditemmodel.html) 開始，他們提供更多 default implementation。Qt 還提供 [QFileSystemModel](https://doc.qt.io/qt-6/qfilesystemmodel.html), 和 SQL 系列的 model，這裡不贅述。\n\n## Views\n所有的 view 都繼承於抽象類 [QAbstractItemView](https://doc.qt.io/qt-6/qabstractitemview.html)，三種主要的: \n- [QListView](https://doc.qt.io/qt-6/qlistview.html)\n- [QTableView](https://doc.qt.io/qt-6/qtableview.html)\n- [QTreeView](https://doc.qt.io/qt-6/qtreeview.html)\n\n事實上，[QColumnView](https://doc.qt.io/qt-6/qcolumnview.html), [QHeaderView](https://doc.qt.io/qt-6/qheaderview.html) 也是繼承自 `QAbstractItemView`。但改變 header 的需求較少，同樣不贅述。\n\n### Delegate \n- 官方文件: [QStyledItemDelegate Class](https://doc.qt.io/qt-6/qstyleditemdelegate.html#subclassing-qstyleditemdelegate)\n- 官方範例[Star Delegate Example](https://doc.qt.io/qt-6/qtwidgets-itemviews-stardelegate-example.html):  C++ 範例，\n\t- PyQT5 的版本可以看: [PyQT5  Delegate Example](https://github.com/baoboa/pyqt5/blob/master/examples/itemviews/stardelegate.py)。\n\n當遇到沒辦法透過 Standard Delegate (QStyledItemDelegate) 呈現的 Data Type 就需要自己定義 Delegate。\n- 和渲染相關的:\n\t- `paint` 改變渲染的方式\n\t- `sizeHint` 決定呈現的 item 大小\n- 和編輯相關的: 可在 tableview 放自訂的 QWidget Editor，跟這些 function 有關\n\t- `createEditor`: 回傳要放在表格裡，讓 User 編輯資料的 widget\n\t- `setEditorData`: 提供 editor 資料\n\t- `setModelData`: 對 model 更新資料\n\t在一般的情況下，delegate 不需要客製化，這塊稍後再提。\n## Convenience Classes\n除了以上基本的 Model View，QT 還提供了其他的 class，這些 class 預先 implement 了一些 function，讓使用者不必手把手實作抽象類的 function。\n### Widget\n如果用途非常簡單，不需要自己控制 model，可以考慮使用 [QListWidget](https://doc.qt.io/qt-6/qlistwidget.html), [QTreeWidget](https://doc.qt.io/qt-6/qtreewidget.html)與 [QTableWidget](https://doc.qt.io/qt-6/qtablewidget.html)。\n- 優點: 已經套好 model/view，直接套用就有成品。\n- 缺點: 不能隨意替換 model，對 view 的控制權比較差。\n\n## Reference \n\n- 官方文件: [model/view framework](https://doc.qt.io/qtforpython-5/overviews/model-view-programming.html#model-view-programming)"
    },
    {
        "metadata": {
            "title": "pyqt5-When-to-use-QAbstractItemModel",
            "date": "2024-05-23T23:05:00",
            "description": "當資料結構較為複雜、是一個自己實作的物件時，考慮使用 QAbstractItemModel",
            "categories": [
                "Python"
            ]
        },
        "content": "在這個範例中，資料是一個「出差核銷系統」，每一筆資料包含\n\n- 出差人\n- Group (小組)\n- Organization (大組)\n- 起始日\n- 結束日\n- 已呈報\n\n事後，我們需要根據每一筆資料計算些資訊，例如: 差旅長度。並且預期這個系統有延伸的可能，也續會增加「報帳金額」、「日均花費金額」.... \n\n\n\n## QStandardItemModel\n\n使用 `QStandardItemModel`，資料有如 2D excel 表格，優點是 Model 不需要實作。缺點是計算相關資料 (如差旅長度) 時，資料的關聯性差，需要透過 row (同一筆資料)、column (起始日、結束日) 找到需要的資料。\n\n```python\nimport sys\nfrom PyQt5.QtWidgets import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtCore import *\nimport delegates  \ndata = [\n    [\"Amy\",  \"GroupA\", \"orgX\", \"2023-01-01\", \"2023-01-05\", False],\n    [\"Alex\", \"GroupA\", \"orgY\", \"2023-01-03\", \"2023-01-05\", False],\n    [\"Sam\",  \"GroupB\", \"orgP\", \"2023-02-01\", \"2023-02-06\", False],\n    [\"Xem\",  \"\", \"\", \"\", \"\", False],\n]\nheaders = [ \"Name\", \"Group\", \"Org\", \"Start Date\", \"End Date\", \"Reported\"]\n\ndef set_model(app, data):\n    model = QStandardItemModel(app)\n    for row in data:\n        lt = []\n        for i, val in enumerate(row):\n            it = QStandardItem(val)\n            if i == 5: # Reported\n                it.setCheckable(True)\n            lt.append(it)\n        model.appendRow(lt)\n    return model\n\ndef get_duration(st, et):\n    st = (QDate.fromString(st, \"yyyy-MM-dd\")).toPyDate()\n    et = (QDate.fromString(et, \"yyyy-MM-dd\")).toPyDate()\n    res = et - st\n    print(res)\n```\n\n## 不使用 QStandardItemModel\n\n如果已經確定顯示的方法只有 Table 或 List，可以使用 `QAbstractTableModel`，相較於 base class `QAbstractItemModel`，它多實作了 `index`, `parent`，只需要實作  `rowCount`, `columnCount` 之類的方法。使用 `QAbstractItemModel` 則具有面對 `QTreeView` 的彈性，但連 `index` 都需要自己實作。\n\n本例使用  `QAbstractTableModel` 。缺點是需要自己處理放資料的地方、並實作 `rowCount`, `columnCount` 之類的方法。本例用一個 list 儲存 objects。\n\n優點是每一筆資料直接對應一個物件，事後在算差旅天數的時候，可以直接對物件呼叫 `get_duration` 直接取得 -- 把相關的資料跟工具封裝在一起。如果有一些不需要顯示在 GUI 上，卻與物件有關連的資料，也可以直接記載物件上。\n\n```py\nimport sys\nfrom datetime import datetime\n\nfrom PyQt5.QtWidgets import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtCore import *\n\ndef convert_to_datetime(s: str):\n    if s ==\"\":\n        return datetime(2024, 1, 1)\n    return datetime.strptime(s, '%Y-%m-%d').date()\n\nclass TravelData:\n    attrs = [\"name\", \"group\", \"org\", \"startDate\", \"endDate\", \"reported\"]\n    def __init__(self, n, g, o, sd, ed, r) -> None:\n        self.name = n\n        self.group = g\n        self.org = o\n        self.startDate = sd\n        self.endDate = ed\n        self.reported = r\n    \n    def get_duration(self, ):\n        return convert_to_datetime(self.endDate) - convert_to_datetime(self.startDate)\n\nclass MyModel(QAbstractTableModel):\n    def __init__(self, data, p):\n        super(MyModel, self).__init__(p)\n        self._data = data\n\n    def rowCount(self, parent=None):\n        return len(self._data)\n\n    def columnCount(self, parent=None):\n        return len(TravelData.attrs)\n\n    def data(self, index, role=Qt.DisplayRole):\n        if role == Qt.DisplayRole:\n            obj = self._data[index.row()]\n            attr_name = TravelData.attrs[index.column()]\n            val = getattr(obj, attr_name)\n            return val\n        return None\n\n    def setData(self, index, value, role=Qt.EditRole):\n        if role == Qt.EditRole:\n            obj = self._data[index.row()]\n            attr_name = TravelData.attrs[index.column()]\n            setattr(obj, attr_name, value)\n            self.dataChanged.emit(index, index, [Qt.EditRole])\n            return True\n        return False\n    \n    def flags(self, index): # Let cell content is editable\n        return Qt.ItemIsSelectable | Qt.ItemIsEnabled | Qt.ItemIsEditable\n```"
    },
    {
        "metadata": {
            "title": "python-asyncio",
            "description": "asyncio, thread 與 multiprocess 適用的情境，與一份 Asyncio 的入門程式範例。",
            "date": "2022-10-23T23:11:36",
            "categories": "Python",
            "aliases": [
                "/posts/2022-10-23-python-asyncio",
                "/posts/2022-10-23-python-asyncio.html"
            ]
        },
        "content": "Python 自 3.4 開始支援asyncio，但在談及這個模組包之前，首先要了解\n\n- `multiprocess` 是真正的平行處理，可以同時間執行不同的程序 (on different processor)。\n- `thread`, `asyncio` 都只在單一 processor 上，因此多個項目之間實際上同時間只有一個項目能夠運行。對於計算密集的任務，這兩種都無法加速。\n\n以下文章閱讀、摘要自 Real Python 的文章：[Speed Up Your Python Program With Concurrency](https://realpython.com/python-concurrency/#what-is-concurrency)\n\n## Concurrency\n\n> The dictionary definition of concurrency is simultaneous occurrence.\n\n在 Python 中，有這種意義的字眼有很多，thread, process, task... ，細究起來應用的層面又有些微不同。但就比較廣義的敘述上，他們都是「按照順序運行的指令序列」，並不是所謂的「平行處理」。他們的每一個項目，都是由 CPU、或是某一個決策者，決定是否切換到另一個項目。而這個切換的過程，如同把原本正在執行的項目在某個點暫停，切換到另一個項目上，決策者隨時可以再把執行中的項目暫停，切換回原先項目暫停的點，繼續執行（理想上）。\n\n`threading` 採取的是 [pre-emptive multitasking](https://en.wikipedia.org/wiki/Preemption_(computing)#Preemptive_multitasking)，作業系統 (OS) 知道每一條 thread 的存在，並且可以任意的中斷，任意的切換。\n\n`asyncio` 使用的是 [cooperative multitasking](https://en.wikipedia.org/wiki/Cooperative_multitasking)，每一個 task 必須主動告知 OS 自己的任務完成了，釋放自己的執行權力。\n\n### Thread 與 Asyncio 各自的問題\n\n使用 Thread 並不好 debug，且可能面臨 race condition 的問題，為了避免需要花費額外的功夫處理（像是互斥鎖 Mutex），參考： [thread-safe](https://zh.wikipedia.org/zh-tw/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8)。\n\n而 Asyncio 採用 cooperative multitasking 這種「互信」原則的協作方法，如果其中有任務不配合，不肯釋出執行權則滿盤皆輸。如果程式中有 bug 導致該任務長時間的佔據 processor，則會把其他任務卡死。\n\n## Parallelism\n\n採用此種方式的模組是 `multiprocessing` ，Python 會創建完全不同的 process，每一條  process 都有著自己的 python interpreter。由於彼此之間是不同的 process，因此 multiprocess program 可以跑在不同的 CPU core 上。\n\n## I/O-bound vs. CPU-bound\n\n想要透過非同步/平行運算加速程式，首先需要了解程式被卡住的瓶頸為何？這就要談及 I/O-bound 與 CPU-bound。\n\nI/O-bound ：程式在「等待外部資源的 input/output」花費了大量的時間，像是等待網路封包與檔案系統。下圖的 Request (紅色區塊) 可以視為「等待外部資源發送 Request」的期間、而藍色方塊才是街收到 Request 後給予對應處理（計算）所花費的時間。大部分的時間都花費在等待上。\n\n如果程式的瓶頸點在於 I/O-bound，Concurrency 的方法可以帶來速度提昇。不管是 `threading `或 `asyncio`，他們只是透過重新分配任務執行的順序，而非採取序列式執行（下圖）的方式，活用等待時 CPU 沒事做的時間。\n\n![IO-Bound](https://files.realpython.com/media/IOBound.4810a888b457.png)\n\n\n\nCPU-bound：程式並不需要跟網路有什麼交互，沒有等待外部資源的時間，只有長時間的計算。面對此問題，使用  `threading `或 `asyncio` 都沒有好處，因為他們終究只會使用一個 CPU core，計算任務不能在同一顆 CPU 上面重疊。\n\n![CPU-bound](https://files.realpython.com/media/CPUBound.d2d32cb2626c.png)\n\n如果有多核心，使用 `multiprocessing` 可以讓計算任務「平行執行」以達到加速的目的。\n\n![multiprocessing](https://files.realpython.com/media/CPUMP.69c1a7fad9c4.png)\n\n\n\n## 第一份 Asyncio 的程式\n\n### 概念\n\n下面這段程式參考自官方文件的 [Subprocesses](https://docs.python.org/zh-tw/3/library/asyncio-subprocess.html?highlight=create_subprocess_shell#asyncio.create_subprocess_shell) 與 [wait_for](https://docs.python.org/zh-tw/3/library/asyncio-task.html?highlight=wait_for#timeouts)。將會使用 `asyncio` 執行一系列的指令 `cmds`，並設置 timeout，時間到自動把 process 砍掉。\n\n使用 asyncio 最基礎的用法，不外乎繞著 `await`, `async`, `asyncio.run` 幾個關鍵字轉：\n\n- 要花很多時間等待的那行程式，前面加 `await`。\n- function 當中如果有使用 `await`，則 function 前面要加 `async`。\n- 執行 async function 要透過 `asyncio.run` 執行。\n\n另外，subprocess 中可使用的 timeout，在 asyncio 當中要透過 `wait_for` 執行。\n\n\n\n需要注意，這裡 async 的作用是對「等待 subprocess 的 response 」做異步。傳統的 subprocess 要等到 subprocess  結束才能執行下一行，而透過這個方式可以一次丟出多個 subprocess。\n\n### 範例\n\n```python\nimport asyncio\n\nasync def single_process(cmd):\n    proc = await asyncio.create_subprocess_shell(\n        cmd,\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE)\n    try:\n        await asyncio.wait_for(proc.communicate(), timeout=2)\n        print(cmd, \"complete\")\n    except asyncio.TimeoutError:\n        print(cmd, \"timeout\")\n        \nasync def run_all(cmds):\n    lt = []\n    for cmd in cmds:\n        lt.append(single_process(cmd))\n    await asyncio.gather(*lt)\n\nif __name__ == \"__main__\":\n    cmds = [\n        \"sleep 1 && echo hello\",\n        \"sleep 1.5\",\n        \"echo world\",\n        \"sleep 500\",        \n    ]\n    asyncio.run(run_all(cmds))\n```\n\n## 延伸閱讀\n\n- [asyncio由簡入繁](https://www.ithome.com.tw/voice/138875)：是我相當推崇的一位作者所寫的導讀文章！\n- [Python非同步設計：使用Asyncio](https://www.books.com.tw/products/0010867281?sloc=main)：同位作者寫的翻譯書。\n\n- [Multiprocessing VS Threading VS AsyncIO in Python](https://leimao.github.io/blog/Python-Concurrency-High-Level/)\n- [Speed comparison using multiprocessing.Process versus subprocess.Popen](https://stackoverflow.com/questions/47689297/speed-comparison-using-multiprocessing-process-versus-subprocess-popen)\n- [System Slow? How to See If Linux is Memory, CPU, or IO Bound](https://www.howtogeek.com/devops/is-your-linux-system-memory-cpu-or-io-bound/)\n- [Async Python: The Different Forms of Concurrency](http://masnun.rocks/2016/10/06/async-python-the-different-forms-of-concurrency/)\n- [Speed Up Your Python Program With Concurrency](https://realpython.com/python-concurrency/)"
    },
    {
        "metadata": {
            "title": "python-command-interface",
            "description": "蒐集與互動式選單、command interface 相關的模組，可以根據用途找到適合的套件。",
            "date": "2022-10-23T15:25:39",
            "categories": "Python",
            "aliases": [
                "/posts/2022-10-23-python-command-interface",
                "/posts/2022-10-23-python-command-interface.html"
            ]
        },
        "content": "本篇文章是一個蒐集可使用模組的總集，可以根據用途找到適合的套件。\n\n\n## Argparse\n\n[官方套件](https://docs.python.org/zh-tw/3/howto/argparse.html) `argparse`讓寫 CLI 介面變得非常輕鬆，特別提一下 [`nargs` 選項](https://docs.python.org/3/library/argparse.html#nargs)。\n\n`nargs`: 只要為數字 (int) ，回傳的型態會是一個 list 擁有 `nargs` 個元素，因此 `nargs=1` 會是一個 list 內容只有一個元素。而沒有添加 `nargs` 的話，就不會以 list 的形式回傳。除了整數，還有 `+`, `?`, `*` 三種特殊符號可以選，`*` 表示可接受任意數量的輸入參數，`+` 是至少要輸入一個、可接受輸入更多數量的參數，否則會報警告。`?` 表示可接受 1 個或 0 個參數，其結果不會以清單的形式存下，而是 single item。\n\n`nargs='?'` 很適合用於有時候需要求 user 附加檔案路徑的需求。\n\n```python\nimport argparse\ndef get_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--boo', nargs='?') # nargs = 1 or 0, 值不會是清單\n    parser.add_argument('--aoo', nargs='*') # nargs = 0 ~ N\n    parser.add_argument('--coo', nargs='+') # nargs >= 1\n    parser.add_argument('--number', nargs=1)\n    parser.add_argument('--single')   \n\t# Positional Argument\n    parser.add_argument(\"flag1\", nargs='?') # the first positional argument is `flag1`\n    parser.add_argument(\"flags\", nargs='*') # the second ~ N-th positional argument will be collected to `flags`\n\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    args = get_args()\n    print(args.aoo)     # 2 \n    print(args.boo)     # ['1', '2', '3', '4']\n    print(args.coo)     # ['5']\n    print(args.number)  # ['2']\n    print(args.single)  # 1\n\n# python .\\example_argprase.py --aoo 1 2 3 4 --boo 2   --number 2 --coo 5 --single 1 aaa bbb ccc\n```\n\n`parser` 的回傳值是一個 namespace，可以直接用名字取用值，像是上面數字的例子那樣直接用 `args.number` 對 `args` 這個回傳的 namespace 取值。另外還有[互斥選項](https://docs.python.org/3/library/argparse.html#mutual-exclusion)、[Argument groups](https://docs.python.org/3/library/argparse.html#argument-groups) 等進階的用法。\n\n```python\nimport argparse\ndef get_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-u\", \"--update\", help=\"Clean dir\", default=False, action=\"store_true\")\n    # 互斥組\n    group = parser.add_mutually_exclusive_group(help=\"you can only choose 1\")\n    group.add_argument(\"--dessert\", help=\"Get dessert\", default=False, action=\"store_true\")\n    group.add_argument(\"--drink\", help=\"Get drink\", default=False, action=\"store_true\")\n    return parser.parse_args()\n```\n\n## [Curses](https://docs.python.org/3/howto/curses.html)\n\n`curses ` 也是一個 Python 官方的套件，可以使用它開發 console base 的 UI。[Real Python: Your Guide to the Python print() Function](https://realpython.com/python-print/#building-console-user-interfaces) 當中有些示例，像是做個貪吃蛇：\n\n![貪吃蛇](https://files.realpython.com/media/snake.a9589582b58a.gif)\n\n最終沒有涉略這個模組，它似乎都是全螢幕式的，沒有辦法只顯示在打完指令下面的位置，與我的目的不合。\n\n## Inquirer\n\n套件 **[inquirer](https://github.com/magmax/python-inquirer)** 不是 Python 原生的模組，是一個基於 inquire.js 想法產生的 Python 專案，主要支援 Unix 平台，在 [inquirer.js](https://github.com/SBoudrias/Inquirer.js) 裡面有比較多圖片說明。開發上，`pip install inquirer`  即可裝好模組。支援\n\n- 問答，要求使用者輸入內容並包含驗證格式。\n- 清單，提供選項，User 用鍵盤上下鍵選擇答案\n- Check box \n\n簡單舉個例子! \n\n```python\nimport inquirer\nimport os \n\nquestions = [\n  inquirer.List('subdir',\n      message=\"cd to which dir\",\n      choices= os.listdir(os.getcwd()),\n  ),\n]\nanswers = inquirer.prompt(questions)\nquestions[\"subdir\"] # user 選到的選項值\n```\n\n不過在 colab 的環境中，它沒辦法提供方向鍵在 console 上的互動，因此在印完內容後會報 error，但若在一般的 Linux terminal 用起來體驗是很不錯的！"
    },
    {
        "metadata": {
            "title": "python-import",
            "description": "關於相對匯入與絕對匯入的優缺點，以及如何迅速解決絕對匯入模組在移動後，需要被匯入時的解決辦法。",
            "date": "2022-06-05T11:11:40",
            "categories": "Python",
            "aliases": [
                "/posts/2022-06-05-python-import",
                "/posts/2022-06-05-python-import.html"
            ]
        },
        "content": "這篇的重點依然在於「相對引用與絕對引用」，但在這之間，先來看一些有關 import 的觀念。\n\n## [概念](https://docs.python.org/3/reference/import.html#packages)\n\n不管它是用 C語言、Python 或其他什麼方式來實作，Python 只有一種型態的模組物件(module object)，所有的 Module 都是這種型態(type)。管理這些 module ，提供他們名稱層級架構的就是 Package。\n\n我們可以把 Package 就想像成一個檔案系統管理檔案的樣子，但它又不完全等價於檔案系統，因為 package 與 module 們不一定需要來自檔案系統。以檔案系統作為類比，是因為 package 如檔案系統一般有分層架構。所有的 package 本質上都是 module，但不是所有的 module 都是 package ，這是一個充分非必要條件。\n\nPackage 可以視為是一種特殊的 module ，更仔細的說：**任何包含有 `__path__` 屬性的 module 會被認為是一個 package**。\n\n> All packages are modules, but not all module are packages. Packages Are a special kind of module; specifically, any module that contains a `__path__` attribute is considered a package.\n\nPython定義了兩種的 package，regular package 和 namespace package\n\n| [Regular package](https://docs.python.org/3/reference/import.html#packages) | Namespace packages                                           |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 不一定非得有 `__init__.py`  才能是 package，但是只要有這個檔案，在 import 到該 package 時，一定會先執行  `__init__.py` 再去執行其他動作。 | 由多個 [portions (直接翻譯：部份)](https://docs.python.org/3/glossary.html#term-portion)構成的，每個 portion 都貢獻一個子模組(subpackage)給父模組(parent package)。Portion  可分佈在檔案系統中不同的地方，資料夾、網路、甚至是 zip file 反正必須是 Python 可以搜尋到的地方。 |\n\n## [Import Search](https://docs.python.org/3/reference/import.html#searching)\n\n當試圖載入模型時，首先會被檢查的地方是 `sys.modules`，這個字典會將**已經載入的模組名稱**(module name) mapping 到已經加載的 module 實例。\n\n### Module Cache\n\n`sys.modules` 是可寫的，但是要很小心、隨意改寫很容易有錯，**總之不要動它**。隨意地刪除 key 有可能不會破壞關聯的 Module (因為其他 module 可能保留對它的reference)。但是，他會使字典的映射功能無效﹔使用該 key 找 module 時找不到，引發 [`ModuleNotFoundError`](https://docs.python.org/zh-tw/3/library/exceptions.html#ModuleNotFoundError)\n\n來實際操作看看：\n\n```python\nimport sys \nprint(sys.modules) # 超多東西\nprint(sys.modules[\"typing\"]) # 挑其中的 typing 出來看\n# <module 'typing' from 'C:\\\\path\\\\to\\\\user\\\\anaconda3\\\\lib\\\\typing.py'>\ntype(sys.modules[\"typing\"])\n# module\n```\n\n`sys.modules` 是一個字典，紀錄著 modeul name : module instance 這樣一組一組的訊息，是匯入模組時第一個搜尋的地方。\n\n### Finders and Loader\n\n若指定的 module name 在 `sys.modules` 中找不到，會調用 Python 的 import 協議 (protocol)，以尋找並加載此 module 。這個協議包含兩個部分: [finders](https://docs.python.org/3/glossary.html#term-finder)  [loaders](https://docs.python.org/3/glossary.html#term-loader)，但將不細講。只要滿足協議，我們甚至可以透過網址(URL)匯入模組。\n\nPython 有它預設的 finder，預設的搜索路徑為`sys.path`，其中包含了這三種位置 ([The Module Search Path](https://docs.python.org/3/tutorial/modules.html#the-module-search-path))\n\n1. 被執行腳本的所在資料夾\n2. [`PYTHONPATH`](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH) (一堆資料夾名稱，是 PYTHONPATH 是機器自身的環境變數之一)\n3. 一些預設的地方，像是 site-packages 資料夾 ([`site`](https://docs.python.org/3/library/site.html#module-site)模組在管理)\n\n## 相對與絕對匯入的比較\n\nPython 社群對於這兩種匯入的制定在這裡: [PEP328 Imports: Multi-Line and Absolute/Relative](https://www.python.org/dev/peps/pep-0328/#rationale-for-absolute-imports)\n\n|      | 絕對匯入                                                     | 相對匯入                                                     |\n| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 優點 | 使用上簡易、直覺                                             | 移動檔案時修改較為方便                                       |\n| 缺點 | 在檔案系統中移動時，需要尋訪檔案中所有 import 的地方，修改層級關係 | 該檔案無法作為腳本執行，必須由其他腳本檔案先 import 該 module 後執行。 |\n\n\n\n## 絕對位置匯入(Absolute Import)\n\n前面提到，Import Search 時會嘗試再 `sys.modules` 所列的路徑中嘗試尋找要被匯入的模組。而對於一些我們自創的、沒有被記載於 `sys.modules` 的模組而言，絕對匯入(absolute import)是指，被引入的 package 使用的是從 root folder 到該 package/module 之間的完整路徑。\n\n```python\nimport foo\n```\n\n像這樣的用法，在 Python 2.4 之前，並沒有明確的說 import 所指的位置應該是 top-level 或是其他 module insider。為了解決這個歧異(ambiguity) 從 Python 2.5 開始，這種 `import foo` 的寫法，被稱為「 **absolute import**」。它代表這個 `foo` 必定是可以透過 `sys.path` 取得的 module 或 package，這稱為絕對匯入。\n\n> To resolve the ambiguity, it is proposed that `foo` will always be a module or package reachable from `sys.path`. This is called an absolute import.\n\n根據 [PEP 328](https://www.python.org/dev/peps/pep-0328/#rationale-for-absolute-imports)，從 python 2.5開始，所有直接`import xxx` 語法，都會是 top-level module : 與 `__main__` 同級(資料夾)的 module。\n\n絕對導入的優點是清楚、架構易懂，但也有著問題：重命名層次結構中 high-level 的 package 時、或是將一個 package 移至另一個 package 時，要去修改所有的程式碼，需要付出較高的代價。\n\n一個簡單粗暴，但就軟體架構規劃未必是好事的作法是，在移動 package 時將「要被 import 的 package」的層級，用 \n\n```python\nsys.path.append(\"path/to/pkg's/parent\")\n```\n\n強制把該 package 加到被搜索行列（ `sys.path`）裡面。\n\n\n\n## 相對匯入 (Relative Import)\n\n當 import package 時 package 前面有 `.` 就是相對匯入。\n\n> A single leading dot indicates a relative import, starting with the current package. Two or more leading dots give a relative import to the parent(s) of the current package, one level per dot after the first. Here’s a sample package layout. \n>\n> Relative imports use a module’s __name__ attribute to determine that module’s position in the package hierarchy. If the module’s name does not contain any package information (e.g. it is set to ‘__main__’) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.\n\n或許我們可以用 tree 來看待這個 import 的過程，在資料結構 tree 當中，同層節點之間是不相連的，每個節點只與父輩與子代相連。要走訪同輩的節點，也需要先走到上一層，再往訪問道目標的同輩節點。相對匯入中的第一個點，不但是告訴電腦「當前的模式是相對匯入!」，也是點出這個樹的根結點 (root) 是「這個檔案的上一層」。有點像是找族譜，兄弟之間是二代血親，當哥哥要計算與弟弟之間是幾等親時，必須先溯源到父親 (一個 dot )，再往下找到弟弟。所以說，相對引入裡面「一個 dot 表示當前位置」可以看做「知道當前的父輩之位置，可以從該父輩往下找到要找到的檔案名稱」\n\n在最標準的起手式`import .pkgName` ，相對路徑的**起點**就是寫這行的**檔案的所在位置**而非 root file 。\n\n- 一個點表示當前包的位置開始引入\n- 兩個點表示上級\n- 三個點表示上上級\n\n以此類推，舉例說明\n\n```python\npackage/\n    __init__.py\n    subpackage1/\n        __init__.py # here!\n        moduleX.py # here! \n        moduleY.py\n    subpackage2/\n        __init__.py\n        moduleZ.py\n    moduleA.py\n```\n\n不管在 `subpackage1/moduleX.py` 或 `subpackage1/__init__.py` 中，下面的導入都是有效的(因為他們同級)。\n\n```python\nfrom .moduleY import spam\nfrom .moduleY import spam as ham\nfrom . import moduleY\nfrom ..subpackage1 import moduleY\nfrom ..subpackage2.moduleZ import eggs\nfrom ..moduleA import foo\n```\n\n- 絕對匯入可以用\n\n  ```python\n  import XXX.YYY\n  from XXX import YYY\n  ```\n\n- 但相對匯入只能用 `from XXX import YYY`  這種語法。\n\n  ```python\n  from .moduleY import spam\n  ```\n\n  另一種寫法是禁止的 \n\n  ```python\n  import .moduleY # 禁止!!!!!!\n  ```\n\n  這是因為寫 `import XXX.YYY.ZZZ` 之後，去除 keyword `import`，`XXX.YYY.ZZZ` 是可使用的(usable)。但是去除 `import` 後`.moduleY` 是一個不可使用的表達方式。\n\n  \n\n### 相對匯入的原則 ([Rationale for Relative Imports](https://www.python.org/dev/peps/pep-0328/#id9))\n\n隨著絕對匯入的作法敲定，出現了一個問題﹔是否該允許相對匯入的存在。相對匯入最大的優點在於：重新編排大型 package 架構時，不需要一個個編輯子模組。此外，沒有相對引入的話在 package 內部的模組無法輕易的 import 自己。也就是說，相鄰的兩個檔案卻需要大老遠從 root 拉路徑過來  import，這種繞遠路的行為十足弔詭。\n\n### 相對匯入的缺點\n\n然而，使用相對路徑還是有些須注意的地方：\n\n1. 使用了相對路徑的檔案沒辦法直接執行(不能作為 `__main__`)\n2. 由於相對路徑變得要計算套件之間的上下層關係來決定 import，**因此 top level 不能低於被匯入的套件**。需要在 import 套件中最高層的位置的**再上一層**，建立呼叫這一整套 package 的 .py 作為直接執行的檔案（他就是 `__main__`）。\n\n某些程度上這種作為變得十足麻煩，想測試套件還需要往上爬一層創立另一個檔案再來 import …. ，甚至有些專案會把相對路徑跟絕對路徑都寫出來：\n\n```python\ntry: \n    from .where import package \nexcept:\n    from where.package import * \n```\n\n我曾經在 stackoverflow 看到一則討論在說為何用了相對路徑的 python 檔不能執行？這很麻煩。而某位網友說：「使用相對路徑的檔案你應該視為『套件』而非『腳本 (script) 』」。\n\n或許正因為這個原因，比起嫌相對路徑比絕對路徑麻煩，更應該把相對路徑跟絕對路徑本來當作是在不同的場合所使用的…. 這樣的思路來思考吧。\n\n## Reference \n\n- [理解Python的 relative 和 absolute import](https://carsonwah.github.io/15213187969322.html)"
    },
    {
        "metadata": {
            "title": "python-logger-quick",
            "date": "2022-01-20T23:11:51",
            "categories": "Python",
            "description": "提供一個快速使用 logger 的 code snippet",
            "aliases": [
                "/posts/2022-01-20-python-logger-quick",
                "/posts/2022-01-20-python-logger-quick.html"
            ]
        },
        "content": "在開發 Python 專案時，是否經歷過一種狀況：在測試的時候需要不斷輸出一些資訊以便觀察狀態，但在正式上線之後又不須要這些東西輸入。有可能是不想給使用者看到，也有可能是不斷 print out 會造成某些阻塞。\n當開發版與上線版之間在切換時，最樸實無華的作法就是打開程式，一行行的把 Print 註解掉，但這顯然非常的沒有效率。\n\n<!--more-->\n\nPython 的原生套件中有一個名為 `logging` 的模組，在一些較為正式的模組套件包中都不難看到它的蹤影。\n\n本篇文章接下來的內容大多是閱讀 Python 官方文件後的快速整理，希望能將 logging 模組簡單的介紹並上手！細部的設定會放在下一篇文章。建議使用電腦觀看，透過左邊的目錄快速切換！\n\n## 日誌等級的基本認知\n\n預設的 logging 訊息等級一共有五個，其中 **logging 的日誌等級預設是 WARNING(30)** ，因此在預設的情況下，數值小於30的日誌等級不會輸出。\n\n| 等級     | 數值 |\n| -------- | ---- |\n| DEBUG    | 10   |\n| INFO     | 20   |\n| WARNING  | 30   |\n| ERROR    | 40   |\n| CRITICAL | 50   |\n\n## 單一模組：使用 logging 即可\n\n### 直接使用\n\n不設定 handler，也不設定`basicConfig` ，預設是輸出到終端機上(terminal/stdout)。如前面所說，logging 的日誌等級預設是 `WARNING(30)`。因此低於 WARNING 的 INFO 沒有被輸出在 terminal。\n\n```python\nimport logging\nlogging.warning('Watch out!')  \nlogging.info('I told you so') \n```\n\n```\nWARNING:root:Watch out!\n```\n\n### 寫入日誌檔案 \n\n多數的情況需要儲存、以供事後查看這些紀錄檔案，例如訓練深度學習模型的時候，或是執行一個長時間運行的系統的時候。\n\n```python\nimport logging\nlogging.basicConfig(filename='example.log', level=logging.DEBUG)\nlogging.debug('This message should go to the log file')\nlogging.info('So should this')\nlogging.warning('And this, too')\n```\n\n如此一來將不會有任何輸出，但查看當前的執行目錄會發現 `example.log` 這個檔案裡有寫入日誌訊息。由於`basicConfig` 函式中，設置了等級為 DEBUG等級 (10)，因此三行訊息都有被包含進去。\n\n```\n# example.log 內部的長相\nDEBUG:root:This message should go to the log file\nINFO:root:So should this\nWARNING:root:And this, too\n```\n\n如果重複執行上面的程式，日誌會不斷的加在`example.log`當前內容的後面，想要每次都直接刷新日誌檔案而不是接續(append)，需要加上參數 `filemode=w` 。\n\n```python\nlogging.basicConfig(filename='example.log',filemode='w',  level=logging.DEBUG)\n```\n\n## 多重模組：使用 logger \n\n多數情況我們所要面臨的狀況並沒有那麼簡單，專案是具有架構層級的模組，每個檔案都各自使用 logging 險得雜亂無章。後面會仔細介紹設定，這裡先簡單的提供了一個 function 可以直接調用。\n\n它將創建一個 logger，將輸出導向 terminal (stdout)、並自動儲存日誌到檔案。但以下幾點需要注意：\n\n1. 不使用層級：直接使用 `get_logger()`，返回的 logger 不會有層級。`rootName` 參數可自由選擇是否更改，但 child 請設為空\n\n   ```python\n   logger = get_logger(rootName=\"__main__\", childName=\"\")\n   ```\n\n2. 根據程式的 package 層級自動設定：要把 `childName=__name__`在子程式中打上去！\n\n   ```python\n   logger = get_logger(rootName=\"__main__\", childName=__name__)\n   ```\n\n3. 自定義層級：同時覆蓋 rootName, child 自己寫層級架構。\n\n   ```python\n   get_logger(rootName=\"parent\", childName=\"child1.child2\")\n   ```\n\n除了 `rootName` 與 `childName` 兩個參數是會影響到 logger 層級的，其他都是有關 log file 的參數：\n\n- `fileName`：可自訂 log file 的名稱\n- `timeFalg`：是否要再檔名後面自動添加當前的時間戳，如此能使 log file 不被覆蓋，因為函式中預設的寫入行為是覆寫(`w`)。\n- `log_dir`：log file 所儲存的資料夾，預設會在當前的目錄下創建一個名為 `logs` 的資料夾，並將紀錄都存在裡面。\n\n如果有不只一個 python 檔在跑，且彼此沒有上下層級關係，記得覆寫 rootName，不要讓兩個 logger 同名，否則當其中一份程式碼中跑到新增訊息，輸入的訊息會讓兩個程式的 logger 都接收到，影響到彼此的 output。\n\n```python\nimport logging, sys, os\n\ndef get_logger(rootName=\"__main__\", childName=\"\", fileName=\"record\", timeFlag=True, log_dir=\"logs\"):\n    logName = rootName if not childName else  rootName+\".\"+childName\n    print(\"Your Log name is : \", logName)\n    logger = logging.getLogger(logName) \n    logger.setLevel(logging.DEBUG)\n    if timeFlag:\n        from datetime import datetime\n        now = datetime.now()\n        dt_string = now.strftime(\"%m%d_%H%M%S\")\n        fileName+=\"_\"+dt_string\n        \n    if not os.path.isdir(log_dir):\n        os.mkdir(log_dir)\n    \n    fileName = os.path.join(log_dir, fileName)\n\n    if not childName: # 只能在最頂層加，如果每一層都這樣加，每一個 child logger 也會都 print 一行\n        # file handler\n        fh = logging.FileHandler(fileName+\".log\",mode='w', encoding='utf-8-sig')\n        fh.setLevel(logging.INFO)\n        ch = logging.StreamHandler() # sys.stdout\n        ch.setLevel(logging.DEBUG)\n\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s : %(message)s')\n        # formatter = logging.Formatter('%(message)s')\n        ch.setFormatter(formatter)\n        fh.setFormatter(formatter)\n\n        # put filehandler into logger\n        logger.addHandler(fh)\n        logger.addHandler(ch)\n    return logger\n```\n\n### 簡易範例\n\n1.  Root file，執行的時候是 `python xxx.py` 的那個 `xxx.py` 的檔案中應該這樣調用 logger : \n\n    ```python\n    logger = get_logger(rootName=__name__)\n    ```\n\n2.  Child file，被 `xxx.py` 所調用的模組\n\n    ```python\n    logger = get_logger(childName=__name__)  \n    ```\n\n不管是哪個檔案，使用 logger 的時候都直接按照訊息層級的嚴重性，正常使用即可: \n\n```python\nlogger.debug(\"just debug desp\")\nlogger.info(\"some information\")\nlogger.warning(\"This is warning, your action may cause some unexpected effect.\")\nlogger.error(\"something wrong!\")\nlogger.critical(\"Your code is dead!!\")\n```\n\n**Hint 1.** 如果覺得預設的 logger 格式太過冗長，可以參考下一章改變範例 code 中的 `formatter` 達成。\n\n**Hint 2.** 如果希望錯誤/例外發生時，可以把 trace 一併寫進去，參考後面的 [紀錄例外的traceback訊息](#紀錄例外的traceback訊息)。 \n\n### 層級架構說明\n\n程式中的說明文字，具體範例如下:\n\n#### 狀況1. 都不使用\n\n完全不使用層級的話，大可以所有的檔案都如下: \n\n```python\nlogger = get_logger(rootName=__name__)\n```\n\n但強烈不建議，如果這樣何必搞 logger，直接用 logging 就好了吧。\n\n#### 狀況2. 根據套件層級自動設定\n\n簡易範例中即示範了此種狀況，這種情況下，**請勿改變 root file 中 logger 的 rootName 屬性**，讓他保留範例中的樣子，也就是 `__name__` (在 main file 中 `__name__ == __main__`) \n\n#### 狀況3. 手動設定層級名稱\n\n想搞怪? 自己設定層級名稱! \n\n```python\nlogger1 = get_logger(rootName=\"boss\")\nlogger2 = get_logger(rootName=\"boss\", childName=\"manager\")\nlogger3 = get_logger(rootName=\"boss\", childName=\"manager.department\")\nlogger4 = get_logger(rootName=\"boss\", childName=\"manager.department.engineer\")\n```\n\n\n\n## 訊息格式\n\nlogging 模組中，使用最原始的表達方式 `%s` 常常是為了向下兼容\n\n```python\nimport logging\nlogging.warning('%s before you %s', 'Look', 'leap!')\n```\n\n### 改變訊息的呈現格式\n\n透過`logging.basicConfig` 的 `format` 參數設定 log 的訊息模式，可以動用的變數可以參考[官方網站](https://docs.python.org/3.7/library/logging.html#logrecord-attributes)，羅列了使用者可以動用的各種資訊，像是 function Name, … 各種的。\n\n```python\nimport logging\nlogging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)\nlogging.debug('This message should appear on the console')\nlogging.info('So should this')\nlogging.warning('And this, too')\n\n''' \nDEBUG:This message should appear on the console\nINFO:So should this\nWARNING:And this, too\n'''\n# %(levelname)s = DEBUG, INFO, WARNING... \n# %(messages)s = ()裡面的訊息\n \n```\n\n## 紀錄例外的traceback訊息\n\n- `logger.exception('any msg')` ：**直接使用 exception層級，會將堆疊訊息寫進去 log 中**。層級為 error 層級\n- `exc_info=True` 若想把例外訊息以**其他層級寫入**，可以把此參數調成True。預設為False，不會把堆疊訊息寫入。\n\n```python\nimport traceback\n\ndef main_loop():\n    for i in range(10):\n        logger.info(f'print {i}')\n        if i== 5:\n            raise Exception(\"Break\")\ntry:\n    main_loop()\nexcept Exception:\n    # 將引發例外的堆疊訊息寫入logger, 甚麼動作都不用下\n    logger.exception('') \n    # 堆疊訊息以info的層級寫入\n    logger.info('info has exc_info',exc_info=True)\n    # 當例外發生時，只會當純的寫入此行，因為 exc_info=False\n    logger.warning('warning without exc_info',exc_info=False)\n    \n    # [Optional] 只將traceback的紀錄寫進指定txt\n    traceback.print_exc(file=open('traceback_INFO.txt','w+'))\n```"
    },
    {
        "metadata": {
            "title": "python-logging-advance",
            "date": "2022-01-22T16:41:38",
            "categories": "Python",
            "description": "logging 模組第二篇，有關過濾特定內容、將日誌內容輸出到特定的目的地、日誌格式可調用哪些系統參數等，模組中四個常見物件的使用方式。",
            "aliases": [
                "/posts/2022-01-22-python-logging-advance",
                "/posts/2022-01-22-python-logging-advance.html"
            ]
        },
        "content": "Logging 模組中主要就是這四種物件：\n\n- Loggers : 提供直接讓其他應用程式使用的接口 (expose the interface that application code directly uses)\n- Handlers : 發送日誌紀錄到適合的目標地點，像是檔案、stdout、甚至 Qt GUI 等等。\n- Formatters : 輸出的格式。\n- Filters : 過濾器，決定哪些日誌訊息可以傳到輸出。\n\n## [Loggers](https://docs.python.org/3/howto/logging.html#advanced-logging-tutorial)\n\nlogger 負責三個工作\n\n1. 暴露一些方法讓應用程式去調用，在執行期間(runtime) 中紀錄訊息。\n2. 根據嚴重性或 filter 物件，決定讓那些訊息要傳遞出去。\n   - 預設的過濾條件就是根據嚴重性(severity)\n3. 將相關的日誌訊息傳遞到相關的 log handlers 手上。\n\n### 常用的方法\n\n* `Logger.setLevel()` : 設定嚴重性的 threshold 。\n* `Logger.addHandler()` , `Logger.removeHandler()` : 新增或移除 handler.\n* `Logger.addFilter()` ,`Logger.removeFilter()` : 新增或移除 Filter，\n\n每當 logger 物件被創建時，下面的函數會自動配置產生：\n\n* `Logger.debug()`, `Logger.info()`, `Logger.warning()`, `Logger.error()`, `Logger.critical() `：括號裡面填寫要傳入的日誌訊息， **必須是 string 形式**，剩下的一些參數可以透過 `**kwargs` 傳入 (ex. `exc_info`... )\n\n  - 當紀錄的訊息是從 print 轉過來的時候要注意，所有的訊息要寫在同一條 string 裡面：\n\n    ```python\n    print(f\"var1={var1}\", f\"var2={var2}\")\n    logger.info(f\"var1={var1}; var2={var2}\")\n    ```\n\n    如果像 print 一樣兩個 string 放不同位置，第二個位置的字串會被當作其他參數，必須要改成只有一條 string。\n\n* `Logger.exception() ` : 一個很像 `Logger.error()` 模式的 logger 方法，不同的是它會**追蹤例外發生的紀錄(traceback)** (dumps a stack trace along with it)，這只應該在例外處理中 (exception handler) 使用。\n\n* `Logger.log(level:int, msg: str)` : 除非是用到 **自訂的訊息等級** ，它的效果跟第一點的一樣，但是更加的冗長，沒事可以不要用。\n\n### 注意事項\n\n1. `getLogger()` 回傳的是「和輸入名稱相同的 logger 實例的 reference」，如果沒有指定，則回傳 logger實例名字為 `root` reference。\n\n2. 名稱如之前所提，有上下的層級架構關係\n\n3. 用相同的名稱 呼叫 [`getLogger()`](https://docs.python.org/3/library/logging.html#logging.getLogger) 得到的是 reference :arrow_right: 都參考至相同物件名稱的 logger 物件。\n\n   ```python\n   logger1 = logging.get_logger(\"aaa\")\n   logger2 = logging.get_logger(\"aaa\") \n   id(logger1)==id(logger2) # True\n   \n   # 兩條呼叫到的會是同一個 logger 物件：名為 'aaa' 的 logger object. \n   ```\n\n4. 嚴重性等級的定義：Logger 能接受的訊息等級受到其父代所影響\n\n   1. 如果自己的等級沒有另外定義，會使用父代所定義的訊息嚴重性等級。\n   2. 如果父代沒有定義，會再往上使用「父代的父代」，往上追朔祖先直到有找到清楚的等級定義 (explicitly set level )\n   3. root logger 必然會有一個很清楚的等級定義 (預設是 `warning`) \n\n5. Logger 所定義能通過的訊息等級，會影響到是否能傳遞到旗下的 handler：\n\n   - 如果在 logger 上定義通過 warning (30)，卻在 handler 定義等級 info (20) 就能紀錄，那這樣實際紀錄下來的也只會有 warning 以上的訊息，因為低於 warning 的根本進不來這個 logger 的手上。\n\n6. 不需要為每個logger 都定義 handler，只要對 root logger 做。\n\n   - 由於 child logger 的訊息會往上傳遞，所以只需要在上層的 logger 設置即可。\n   - 但是也可以把往上傳遞的功能關掉：參數 `propagate=False` \n\n## [Handlers](https://docs.python.org/3/howto/logging.html#handlers)\n\nHandler 物件基於所設定的訊息嚴重等級，將日誌訊息派到**對應的目的地**，像是 stdout。Logger 物件對於 handler 的數量沒什麼限制，可以不加、也可以加很多個。光是官方提供的 handler 就多達 10 個以上，常見的輸出到 std out、輸出到檔案、連接到 Socket、傳遞到 http (`Get`, `POST`)、送到 `Queue`...等等。我也實做過把 logger 直接連動到 Qt GUI 的文字板上面過，不用另外從核心程式拉一條線到前端的 GUI，直接利用現有的 logger 即可非常方便！\n\n\nHandler 幾乎沒什麼方法可以調用，與其相關的主要是這幾個方法：\n\n- `Logger.addHandler(hdlr)`\n  - 舉例說明：目標是 (1) 將所有 log 寫進 log file  (2) 所有高於 error 的 msg 丟到 `stdout` (3)所有 critical 等級的寄信寄出去。一共 3個獨立的 handler 負責做各自的事情。所以需要添加三個不同的 handlers，呼應各自要寄送訊息的目的，還有寄送出去的信息等級。\n  - 標準的library 有提供 [很多 handlers](https://docs.python.org/3/howto/logging.html#useful-handlers)，最常用的是 [`StreamHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler) 和[`FileHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.FileHandler)。\n- `setLevel `：handler 也有 `setLevel()` 方法，和前面的 `setLevel` 不同\n\n  - `logger.setLevel()` 設定的是哪些嚴重性的訊息可以**被傳送到** handlers，而 `handler.setLevel()`則是決定哪些程度的訊息**可以被派遣到要目的地 (ex. write to file )**\n- `setFormatter()`：設定 handler 把訊息傳到目的地時候的訊息格式。\n- `addFilter()` and `removeFilter()`：配置和移除 filter 於handler 物件。\n\n## [Formatters](https://docs.python.org/3/howto/logging.html#formatters)\n\n決定訊息的格式，有三個可選擇擇的參數：\n\n1. 訊息字串格式字串 `fmt`：可調用的一些屬性變數參見 [LogRecord attributes](https://docs.python.org/3.7/library/logging.html#logrecord-attributes)\n2. 日期格式字串 `datefmt`: 預設使用  [`time.localtime()`](https://docs.python.org/3/library/time.html#time.localtime) 打下時間戳，預設的格式為 `%Y-%m-%d %H:%M:%S`\n3. style indicator：撰寫模式的提取符號，預設是 `%`，可修改成 `{` 或 `$`。參考不同的 style-indicator 所對應的 formatter 撰寫模式：\n\t```python\n\tlogging.Formatter('%(asctime)s - %(message)s', style='%')\n\tlogging.Formatter('$(asctime)s - $(message)s', style='$')\n\tlogging.Formatter('{asctime} - {message}', style='{')\n\t```\n\n最後舉個例子：\n\n```python\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s : %(message)s')\n```\n\n- `message`：應用程式傳入的日誌訊息\n- `asctime`, `name`, `levelname`： [LogRecord attributes](https://docs.python.org/3.7/library/logging.html#logrecord-attributes) 中所提供可以調用的屬性，分別表示時間、哪個 logger (名稱) 傳入的、訊息等級名稱。\n\n## [Filters](https://docs.python.org/3/library/logging.html#filter-objects)\n\n- 用在 handler 和 logger 上，提供比「訊息緊急程度層級」更細節的過濾規則\n\n- 最基本，不用實做改寫的 filter，提供以「logger 階層等級」過濾的方法：只能通過**低於自己的層級**。例如 : 設定`A.B` ，則只會通過 logger `A.B`, `A.B.C`, `A.B.D`…\n\n  ```python\n  f = logging.Filter(name=\"A.B\")\n  ```\n\n  代表 \"A.B\" 以下(包含)層級的 logger 事件訊息可以通過這個過濾器。\n\n- 如果以空白字串初始化，則所有的事件都可以通過。\n\n- Filter 必須在 log 事件已經被傳送到 handler 前先附加在 handler 上面，才能起過濾的作用。(反正就是一開始先設定好就對了 = = )\n\n預設功能只是基本的，也可以自己設計規則來決定哪些訊息可以通過。想自訂過濾器要做的事情是：\n\n1. 實作一個 `logging.Filter` 類別，並實作其 `filter` 方法\n2. 把這個客製化 filter 實例化後，用 `.addFilter()` 加到 logger 或 handler \n\n```python\n# 稍微用code表示上面的條列項目\nimport logging\n\nclass CustomFilter(logging.Filter):\n    def filter(self, record):\n        # 實作過濾規則 \n        return True # 要 return True 才代表信息被保留\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger()\nf = CustomFilter()logger.addFilter(f)\n```\n\n舉例而言，一個過濾敏感資料的自定義 Filter 範例 https://gist.github.com/acdha/9238791"
    },
    {
        "metadata": {
            "title": "python-visualize-advance",
            "date": "2022-01-27T14:56:12",
            "categories": "Python",
            "description": "紀錄做數據研究時，使用 matplotlib 繪圖的進階操作。直方圖疊加、如何合併 twinx 下不同的圖例(legend)、將圖例移出繪圖區、在軸上使用省略符號..。",
            "aliases": [
                "/posts/2022-01-27-python-visualize-advance",
                "/posts/2022-01-27-python-visualize-advance.html"
            ]
        },
        "content": "## 多個直方圖疊加\n\n- `histtype`\n  - `bar`：傳統的 `bar` 形式圖，屬於同個 bin 不同的資料會肩並肩的橫向排列。\n  - `barstacked`：`bar` 形式的，但是屬於同一個 bin 的不同資料會直接往上疊加。\n  - `step`：只有階梯的框架線，沒有填滿顏色。\n  - `stepfilled`：這是預設方法，除了階梯式之外在加上填滿色彩。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(0)\nn_bins = 10\nx = np.random.randn(1000, 3)\n\nfig = plt.figure()\naxes = fig.subplots(2, 3).reshape(-1)\ncolors = ['pink', 'blue', 'lime']\n\nax = axes[0]\nax.hist(x, n_bins, histtype='bar', color=colors, label=colors, alpha=0.5)\nax.set_title('histtype bar')\n\nax = axes[1]\nax.hist(x, n_bins, histtype='barstacked', color=colors, label=colors, alpha=0.5)\nax.set_title('histtype barstacked')\n\nax = axes[2]\nax.hist(x, n_bins, histtype='step', stacked=True, color=colors, label=colors, alpha=0.5)\nax.set_title('histtype step, stack steps')\n\nax = axes[3]\nax.hist(x, n_bins, histtype='step', color=colors, label=colors, alpha=0.5)\nax.set_title('histtype step')\n\nax = axes[4]\nax.hist(x, n_bins, histtype='stepfilled', color=colors, label=colors, alpha=0.5)\nax.set_title('histtype stepfilled')\nplt.show()\n```\n\n![matplotlib histtype](https://i.imgur.com/tB4vKCK.jpeg)\n\n## 圖例集合\n\n當兩分資料想要放在一起比較，尺度卻又相差過大時常常會使用副軸 `ax.twinx()`，但是副軸上的圖例會被分開。若想要合併圖例，需要手動指定 `legend` 函式內的內容。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(12, 8), dpi=80)\naxes = fig.subplots(1, 2)\ncolors = ['pink', 'skyblue', 'lime']\nax = axes[0]\nax.plot(np.arange(0, 10, 0.1)/10+np.random.rand(100), color=colors[0], label=\"data 1\")\nax_sub = ax.twinx()\nax_sub.plot(np.arange(100, 90, -0.1)+np.random.rand(100), color=colors[1], label=\"data 2\")\nax.legend()\nax_sub.legend()\nax.set_title(\"No secondary axis legend\")\n\nax = axes[1]\nax_sub = ax.twinx()\nplist = []\nplist += ax.plot(np.arange(0, 10, 0.1)/10+np.random.rand(100), color=colors[0], label=\"data 1\")\nplist += ax_sub.plot(np.arange(100, 90, -0.1)+np.random.rand(100), color=colors[1], label=\"data 2\")\nax.legend(plist, [p.get_label() for p in plist], loc=\"best\")\nax.set_title(\"Both axis legends\")\nfig.savefig(\"AxisLegends.jpg\")\n```\n\n![將圖例集合顯示](https://i.imgur.com/pSvuVHf.jpeg)\n\n範例中使用 `plist` 匯集所有的繪圖物件，但需要注意繪圖物件回傳的形式為何。Scatter 回傳的是單純繪圖物件，plot 回傳的則是一個包含繪圖物件的 list ，要視情況將物件蒐集進 `plist`，選擇用 `plist.append(xxx)` 或是 `plist.extend(xxx)`\n\n```\nIn [196]: ax.scatter(np.ones(10), np.random.rand(10))\nOut[196]: <matplotlib.collections.PathCollection at 0x207bc23ad08>\n\nIn [197]: ax.plot(np.arange(0, 10, 0.1)/10+np.random.rand(100), color=colors[0], label=\"data 1\")        \nOut[197]: [<matplotlib.lines.Line2D at 0x207bca2c248>]\n```\n\n\n\n## [Break The axis][Break the axis]\n\n這裡先根據 matplotlib 的教學繪製了這種可以跳躍部份數值的圖：\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\n\nfig = plt.figure(figsize=(8, 8), dpi=80)\ngs = gridspec.GridSpec(2, 2)\n\n# 畫同一張\nax = plt.subplot(gs[:, 0]) \ndata1 = np.random.rand(100, 2)*10+np.array([[0, 100]])\ndata2 = np.random.rand(25, 2)*5\nax.scatter(data1[:, 0], data1[:, 1], color=\"b\")\nax.scatter(data2[:, 0], data2[:, 1], color=\"orange\")\nax.set_title(\"Plot in 1 graph\", fontsize=\"x-large\")\n\n# 切割不同張\nax_up = plt.subplot(gs[0, 1])\nax_bot = plt.subplot(gs[1, 1], sharex=ax_up)\nax_up.scatter(data1[:, 0], data1[:, 1], color=\"b\")\nax_bot.scatter(data2[:, 0], data2[:, 1], color=\"orange\")\n\nax_up.spines['bottom'].set_visible(False)\nax_bot.spines['top'].set_visible(False)\nax_up.xaxis.tick_top()\nax_up.tick_params(labeltop=False)  # don't put tick labels at the top\nax_bot.xaxis.tick_bottom()\n\nd = .015  \nkwargs = dict(transform=ax_up.transAxes, color='k', clip_on=False)\nax_up.plot((-d, +d), (-d, +d), **kwargs)        # top-left diagonal\nax_up.plot((1 - d, 1 + d), (-d, +d), **kwargs)  # top-right diagonal\n\nkwargs.update(transform=ax_bot.transAxes)  # switch to the bottom axes\nax_bot.plot((-d, +d), (1 - d, 1 + d), **kwargs)  # bottom-left diagonal\nax_bot.plot((1 - d, 1 + d), (1 - d, 1 + d), **kwargs)  # bottom-right diagonal\nax_up.set_title(\"Plot in broken axis\", fontsize=\"x-large\")\nplt.show()\n```\n\n![切割軸](https://i.imgur.com/1jZK1wb.jpeg)\n\n其實原始的套件並不好用，網路上有一個 [brokenaxes](https://pypi.org/project/brokenaxes/) 的套件，能讓我們更輕鬆的達成這件事情。\n\n```python\nfrom brokenaxes import brokenaxes \nfig = plt.figure(figsize=(8,8), dpi=80) \nbaxes = brokenaxes(xlims=((-0.001, 5.001), (99, 111)), ylims=((-0.001, 5.001), (99, 111)), hspace=.1) \n\ndata1 = np.random.rand(100, 2)*10+np.array([[100, 100]])\ndata2 = np.random.rand(25, 2)*5\nbaxes.scatter(data1[:, 0], data1[:, 1], color=\"b\")\nbaxes.scatter(data2[:, 0], data2[:, 1], color=\"orange\")\nfig.savefig(\"brokenaxes_pkg.jpg\")\n```\n\n![切割軸在兩個維度上](https://i.imgur.com/F9siwYf.jpeg)\n\n\n## [圖例移出繪圖][legend out of plot]\n\n```python\nax.legend(bbox_to_anchor=(1.05, 1.0), loc='upper left')\n```\n\n但需要注意，將圖例移出繪圖之後，圖例很容易被切掉。我自己是在環境有寫 matplotlibrc 檔案，裡面有設置自動調整版面 :\n\n```\nfigure.autolayout: True\n```\n\n如果沒有寫 matplotlibrc ，要記得對繪圖做 `fig.tightlayout()`\n\n[legend out of plot]:<https://www.delftstack.com/zh-tw/howto/matplotlib/how-to-place-legend-outside-of-the-plot-in-matplotlib/> \"Matplotlib 中如何將圖例放置在繪圖之外\"\n\n## 假色圖\n\n```python\ndata1 = np.repeat(np.sin(np.linspace(0, 1, 10)).reshape(1,-1), 10, axis=0)\npc = ax.pcolor(data1.T, cmap=plt.cm.Blues, vmin=0, vmax=1)\nax.set_title(\"Sin\")\nfig.colorbar(pc, ax=ax, orientation=\"horizontal\")\n```\n\n在下圖一併展示\n\n## 熱力圖\n\n```python\nx = np.random.randn(1000)\ny = np.random.randn(1000)\nheatmap, xedges, yedges = np.histogram2d(x, y, bins=1000)\nheatmap = gaussian_filter(heatmap, sigma=16)\nextent = [xedges[0], xedges[-1], yedges[0], yedges[-1]]\nimg = heatmap.T\npc = ax.imshow(img, extent=extent, origin='lower', cmap=cm.jet,)\nfig.colorbar(pc, ax=ax, orientation=\"horizontal\", )\n```\n\nHeatmap 的程式碼參考: [Generate a heatmap in MatPlotLib using a scatter data set][heatmap]\n\n\n\n![Heatmap 的展示與圖移出圖例](https://i.imgur.com/F1yQcLB.jpeg)\n\n---\n\n\n\n[Brokenaxes]:<https://github.com/bendichter/brokenaxes> \"brokenaxes (github package)\"\n[Break the axis]: <https://matplotlib.org/3.1.0/gallery/subplots_axes_and_figures/broken_axis.html> \"Broken Axis (matplotlib)\"\n[heatmap]: <https://stackoverflow.com/questions/2369492/generate-a-heatmap-in-matplotlib-using-a-scatter-data-set> \"熱力圖\""
    },
    {
        "metadata": {
            "title": "python-visualize-basic",
            "date": "2021-12-30T18:27:08",
            "categories": "Python",
            "description": "使用 matplotlib 繪圖的常用基本操作，有關子圖操作、合併子圖、跨行跨列、縮減圖上空白區、以及環境設定檔 matplotlibrc的建立。",
            "aliases": [
                "/posts/2021-12-30-python-visualize-basic",
                "/posts/2021-12-30-python-visualize-basic.html"
            ]
        },
        "content": "## 子圖\n\n### `add_subplot`\n\n初使用時最常接觸的就是這個方法，當要用某張子圖的時候再使用 `fig.add_subplot()` 得到某個 `ax` ，用它進行繪圖。\n\n```python\nimport matplotlib.pyplot as plt\nfig = plt.figure(figsize=(20, 16), dpi=300) \nfig.suptitle(\"Big title\", fontsize=20)\n\n# 子圖 1\nax = fig.add_subplot(2, 1, 1)\nax.title.set_text(\"Subtitle 1\")\nplt.plot(np.arange(1, 11), color='b', label=\"lr\", alpha=0.7)\nax.legend() # 圖例\n\n# 子圖 2\nax = fig.add_subplot(2, 1, 1)\nax.title.set_text(\"Subtitle 1\")\nplt.plot(np.arange(1, 11), color='r', label=\"lr\", alpha=0.7)\nax.legend()\n\nplt.savefig(\"fileName.png\")\n\n```\n\n但我並不喜歡這個用法，以上面這份程式為例，這總作法會讓 `fig.add_subplot(2, 1, 1)` 散布在整份程式中，一旦我要修改子圖在行列上的數量，修正起來變得無比麻煩。\n\n### 一口氣指定完子圖\n\n一種方法是：\n\n```python\nfig, axes = plt.subplots(n_rows, n_cols)\n```\n\n不錯的是可以一口氣解決，但我更喜歡另一種作法：\n\n```python\nfig = plt.figure(figsize=(10, 8), dpi=100)\naxes = fig.subplots(2, 3).reshape(-1) # axes.shape: (6, )\naxes = fig.subplots(2, 3)             # axes.shape: (2, 3)\n```\n\n原先的作法在取用 `axes` 的時候，要謹慎的選取 `axes[0][1]` 之類的 index ，同樣的一旦子圖在行列上的數量改變，透過 index 取得 `ax` 的時候也很容易出錯。因此我習慣先把他 `reshape` 成一個維度，直接用 `ax = axes[i]` 取用，簡單省事。缺點是難以知道現在處於哪一行哪一列，如果子圖有需要落在確切位置的需求，這個簡單粗暴的方法可能就不太適合。\n\n### 大標題\n\n```python\nax.set_title(\"sub plot title\") # 子圖的標題\nfig.suptitle(\"Figure title\")   # 整張圖的大標題\n```\n\n### 合併子圖、跨行跨列\n\n#### `subplot2grid`\n\n上面的用法都是規規矩矩，每張子圖大小一致。想要讓圖的形狀跨越多欄多列，應該使用 `subplot2grid`。[subplot2grid example][subplot2grid example]\n\n```python\nax1 = plt.subplot2grid((3,3), (0,0), colspan=3)\nax2 = plt.subplot2grid((3,3), (1,0), colspan=2)\nax3 = plt.subplot2grid((3,3), (1, 2), rowspan=2)\nax4 = plt.subplot2grid((3,3), (2, 0))\nax5 = plt.subplot2grid((3,3), (2, 1))\n```\n\n得到的圖相當於：\n\n![subplot2grid](https://matplotlib.org/3.1.1/_images/sphx_glr_demo_gridspec01_001.png)\n\n事實上 `subplot2grid` 依然可以作到像是 `subplot` 這樣只給出正規方正的子圖，在不做 `colspan`/`rowspan` 的情況下，這兩個操作是等價的：\n\n```python\nax = plt.subplot(2,2,1)  # 1. 算子圖要從 1 開始算子圖\nax = plt.subplot2grid((2,2),(0, 0)) # 2. 先規定整張圖的 (row, col), 在列出要回傳的子圖位於哪個位置 (不像上面是算 index)\n```\n\n#### `GridSpec`\n\n還有另一個方法是透過 `GridSpec` 達成。我們可以先用 `gridspec` 創建一個框架，並把框架的某一塊指派給 `plt.subplot` 真正創建子圖。\n\n```python\nimport matplotlib.gridspec as gridspec\ngs = gridspec.GridSpec(2, 2)\nax = plt.subplot(gs[0, 0]) # 等價 ax = plt.subplot2grid((2,2),(0, 0))\n```\n\n所以，在前面一小節的分隔圖，在這個章節應該如下實做：\n\n```python\ngs = gridspec.GridSpec(3, 3)\nax1 = plt.subplot(gs[0, :])\nax2 = plt.subplot(gs[1,:-1])\nax3 = plt.subplot(gs[1:, -1])\nax4 = plt.subplot(gs[-1,0])\nax5 = plt.subplot(gs[-1,-2])\n```\n\n#### `subplot2grid` 與 `GridSpec` 的差別\n\n我覺得可這樣看待\n\n- `subplot2grid` 屬於 pyplot 類別中，它直接與畫面操作有關，所以直接指派位置就有圖出來了\n\n  ```\n  ax = plt.subplot2grid((2,2),(0, 0))\n  ```\n\n- 但是 `gridspec` 不是屬於 pyplot ，如果只有創建而沒有再指定畫布，是不會出現東西的\n\n  ```python\n  import matplotlib.gridspec as gridspec\n  gs = gridspec.GridSpec(2, 2)\n  plt.show() # 不會有圖跑出來喔\n  ```\n\n此外，gridspec 能做到的 layout(布局) 也更加彈性，詳細可以在這篇裡面看: [Customizing Location of Subplot Using GridSpec](https://matplotlib.org/2.0.2/users/gridspec.html#customizing-location-of-subplot-using-gridspec) ，中文版: [使用 GridSpec 自定义子图位置](https://wizardforcel.gitbooks.io/matplotlib-user-guide/content/3.3.html)。\n\n![gridspec 更加彈性的布局](https://matplotlib.org/2.0.2/_images/demo_gridspec06.png)\n\n## 圖上標示與設置\n\n### 限制座標軸數值\n\n限制 x 與 y 軸顯示的數值上下界。\n\n```python\nax.set_ylim([0, 0.1])\nax.set_xlim([0, 10])\n```\n\n### 繪製橫/直線\n\n```python\nax.axhline(y=0.03, color='r', linestyle='-.', alpha=0.2)  # 橫線\nax.axvline(x=5, color='b', linestyle='-*', alpha=0.2)  # 直線\n```\n\n### [縮減空白邊緣][tight_layout]\n\n```python\nfig.tight_layout(rect=[0, 0.03, 1, 0.95]) # 保留標題的空間\nfig.suptitle(\"title\")\nfig.savefig(\"fig.png\")\n```\n\n`tight_layout` 要在所有繪圖都結束之後，就要 `savefig` 或是 `plt.show()` 之前再放才會生效！或是在 import之後直接改變全局：\n\n```python\nimport matplotlib.pyplot as plt\nplt.rcParams[\"figure.autolayout\"] = True\n```\n\n## [全局的設置 `matplotlibrc`][The matplotlibrc file]\n\n`matplotlib` 裡面有很多設定，包含 `dpi`, `figsize`, `color`, `linewidth`…..，如果希望一些改變能夠直接作用在 global 上，可以透過設定 `matplotlibrc` 檔案達成：\n\n在沒有使用 `style.use('<path>/<style-name>.mplstyle')` 指向設定檔時，預設的搜索順序是這樣：\n\n1. 當前資料夾：當前這個資料夾中存在 `matplotlibrc`，而在這個資料夾之中所有的繪圖，也都想用這樣的設定套用，那非常適合這麼做。\n2. 如果存在環境變數 `$MATPLOTLIBRC`：如果這是個檔案，就直接用。如果是個資料夾，會尋找並使用其下的 `$MATPLOTLIBRC/matplotlibrc` \n3. 恩，剩下兩條我覺得太麻煩了，懶得翻譯。可以去看原文。\n\n如果上述的路徑下都沒有  `matplotlibrc` 檔案那不會再額外搜索其他地方。我們可以直接透過下面這個的作法尋找當前使用的是誰：\n\n```python\nimport matplotlib\nmatplotlib.matplotlib_fname()\n```\n\n#### 我的 `matplotlibrc` 檔案\n\n```matplotlibrc\nfigure.autolayout: True\nlegend.fontsize:   large\nfigure.titlesize:   x-large\nfigure.dpi:  100\naxes.titlesize:     x-large \nimage.cmap: hsv\nhist.bins: 20 \n```\n\n\n\n---\n\n\n\n[subplot2grid example]:<https://matplotlib.org/3.1.1/gallery/userdemo/demo_gridspec01.html#sphx-glr-gallery-userdemo-demo-gridspec01-py> \"matplotlib 官網 subplot2grid 的範例\"\n[tight_layout]: <https://stackoverflow.com/questions/55767312/how-to-position-suptitle> \"stackoverflow: How to position suptitle?\"\n\n[The matplotlibrc file]:<https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=figure.autolayout#the-matplotlibrc-file> \"matplotlib 官網 subplot2grid 的 matplotlibrc 設置\""
    },
    {
        "metadata": {
            "title": "PythonQt-embed python qt in C++",
            "date": "2024-06-01T05:30:00",
            "description": "研究 PythonQt 模組",
            "categories": [
                "Python"
            ]
        },
        "content": "## Install PyQt5\n```bash\nsudo apt install qtbase5-dev\nsudo apt install libqt5widgets5\nsudo apt install libqt5widgets5\nsudo apt install libqt5gui5\nsudo apt install qtbase5-private-dev\n\n# web engine related.\nsudo apt install qtwebengine5-dev qtwebengine5-dev-tools libqt5webengine5 libqt5webenginewidgets5\n\n```\n## Install PythonQt\n我的環境是 WSL\n\n1. git clone PythonQt\n\n    ```bash\n    git clone https://github.com/MeVisLab/pythonqt.git\n    ```\n2. 參考 [Building](https://mevislab.github.io/pythonqt/Building.html) 頁面 Linux 的環節\n\n    ```bash \n    cd $PythonQtRoot\n    qmake\n    make all \n    ```\n\n### [fatal error: 'private/qmetaobjectbuilderp.h'](https://stackoverflow.com/questions/65924650/how-to-build-pythonqt-in-ubutnu)\n安裝 `qtbase5-private-dev`\n```bash\nsudo apt install qtbase5-private-dev\n```\n\n## Compile The First App\nPythonQt 提供了 `pro` 檔案於 `$PYTHONQT_ROOT/build`底下，這種檔案用於 qmake，如果想使用 cmake 則需另外轉換。\n\n下面的範例導入了 core 跟 widgets 兩個模組，如果有用到其他模組，像是 [`QWebEngineView `](https://doc.qt.io/qt-6/qwebengineview.html)，就繼續往後加。加的關鍵字可以看 QT 網站上，會寫這個元件的 qmake 要寫什麼，以 `QWebEngineView` 來說就是 `QT += webenginewidgets` (search: qmake)\n\n```cmake\nQT += core widgets # 如果有用到其他 module 加在這裡\n\nCONFIG += c++11\nLOC  = ABS/PATH/TO/PYTHONQT\n\n# Include the .prf files\ninclude($$LOC/build/common.prf)\ninclude($$LOC/build/PythonQt.prf)\ninclude($$LOC/build/PythonQt_QtAll.prf)\n\n# Specify the source files\nSOURCES += main.cpp\n\n# Include directories (optional, if not specified in .prf files)\n# INCLUDEPATH += /usr/include/qt5 /usr/include/qt5/QtCore /usr/include/qt5/QtWidgets $$LOC/pythonqt\n\n# Library directories (optional, if not specified in .prf files)\nLIBS += -L/usr/lib/x86_64-linux-gnu -L$$LOC/lib\n\n# 不想把 lib 放在 LD_LIBRARY_PATH 要設 RPATH，QMAKE_RPATHDIR 是讓 qmake 在生成 command 時設 rpath 的 info\nQMAKE_RPATHDIR += $$LOC/lib\n\n# 執行檔名稱\nTARGET = gui\n```\n\n## 官方範例\n\n- Source code 在: [PythonQt/examples](https://github.com/MeVisLab/pythonqt/blob/master/examples/)，但範例在 `$PYTHONQT_ROOT/lib` 底下! \n\n- 執行範例的時候，記得把 Lib 加入 `LD_LIBRARY_PATH`\n\n    ```bash\n    export LD_LIBRARY_PATH=$PYTHONQT_ROOT/lib\n    ```\n\n- For example:\n\n    `PyLauncher` 是其中一個範例，功能是會執行傳入的 py 檔，如果檔案無效會發出警告。\n\n    下面讓 `PyLauncher` 執行另一個 example 的 py 檔: \n\n    ```bash\n    cd $PYTHONQT_ROOT/lib\n    ./PyLauncher ../examples/PyGuiExample/example.py\n    ```"
    },
    {
        "metadata": {
            "title": "qt5-qpointer",
            "date": "2024-06-14T00:33:00",
            "categories": [
                "cpp"
            ],
            "description": "試圖用 pointer 指涉 Qt 物件時，為何要使用 QPointer 取代 C raw pointer"
        },
        "content": "## QPointer\n\nQt 稱 QPointer 為 \"guarded pointer\"，指其行為有如 C raw pointer，唯一差在當 QPointer 指涉的對象被銷毀時，QPointer 會指向 nullptr，而原生的 C++ Pointer 會依然會指向原先的記憶體位置，而導致 dangling pointers。\n\n它只是 C raw pointer 的進化版，並不是 smart pointer。Qt 另外有類似於 smart pointer 的存在，例如: [QSharedPointer](https://doc.qt.io/qt-6/qsharedpointer.html) 對照於 C++ 的 `std::shared_ptr`。\n\n下面以兩個例子說明 QPointer 帶來的好處\n1. 當類別具有未初始化的 QPointer member data 不會造成 null check 失效\n2. 當 Qt Object 銷毀，不會導致  dangling pointers\n\n## 範例 1 類別沒有初始化 Member Data 的 Qt Pointer\n\n```cpp\n#include <QApplication>\n#include <QPointer>\n#include <QLabel>\n#include <iostream>\n\nclass A {\npublic:\n    A() {}; \n    ~A() {};\nprivate:\n    QLabel*           m_a; \n    QPointer<QLabel>  m_b; \npublic: \n    void show() {\n        if (m_a) {\n            std::cout << \"A::m_a has value: \" << m_a << std::endl;\n        } else {\n            std::cout << \"A::m_a is null: \" << m_a << std::endl;\n        }\n        if (m_b) {\n            std::cout << \"A::m_b has value: \" << m_b << std::endl;\n        } else {\n            std::cout << \"A::m_b is null: \" << m_b << std::endl;\n        }\n    }\n};\nint main() {\n    char* args[] = { (char*)\"AppName\" };\n    int num  = 1;\n    QApplication app(num,args);\n    QLabel* raw_ptr; \n    QPointer<QLabel> label;\n\n    if (label) {\n        label->show();\n    } else {\n        std::cout<< \"label is a nullptr\"  << std::endl;\n    }\n    if (raw_ptr) {\n        std::cout<< \"raw_ptr has value \" << raw_ptr << std::endl;\n    } else {\n        std::cout<< \"raw_ptr is a nullptr \" << raw_ptr << std::endl;\n\n    }\n    std::cout<< std::endl;\n\n    auto a = A();\n    a.show();\n    return app.exec();\n\n}\n\n\n```\n\n輸出\n```\nlabel is a nullptr\nraw_ptr is a nullptr 0\n\nA::m_a has value: 0x5d0000006e\nA::m_b is null: 0\n```\n這個範例中，所有的 Pointer 都沒有初始化\n1. main function (`label` , `raw_ptr` ): 雖然都沒有初始化，但沒有造成記憶體問題，可以透過 Null check 檢查出來\n2. `class A`: \n\t1. 很不幸的，`m_a` 沒有初始化，且有指向一個記憶體位置，這代表它不能透過 null check 找出來。如果因為通過 null check ，而呼叫了 `m_a->show()` 之類的 member function，就可能引發記憶體問題!  \n\t2. 與之相對，`m_b` 也沒有在 constructor 的時候賦值，但是它是安全的。\n\n## 範例2 Qt Object 銷毀\n\n在這個範例中，`r_ptr, q_ptr` 都是先被創建，接著指向同一個物件，並觀察該物件被銷毀後兩個 Pointer 的狀態。\nraw pointer 在原始物件被銷毀後，依然持有原來的記憶體位置。而 QPointer 物件則變回 nullptr。\n```cpp\nQLabel* r_ptr; \nQPointer<QLabel> q_ptr;\nstd::cout<< \"r_ptr, q_ptr: \" << r_ptr << \", \" << q_ptr << std::endl;\n\nQLabel* obj_ptr = new QLabel(\"1\"); \nr_ptr =  obj_ptr;\nq_ptr =  obj_ptr;\nstd::cout<< \"r_ptr, q_ptr: \" << r_ptr << \", \" << q_ptr << std::endl;\n\ndelete obj_ptr;\nstd::cout<< \"r_ptr, q_ptr: \" << r_ptr << \", \" << q_ptr << std::endl;\n```\n輸出\n```\nr_ptr, q_ptr: 0, 0\nr_ptr, q_ptr: 0x55c287a67050, 0x55c287a67050\nr_ptr, q_ptr: 0x55c287a67050, 0\n```\n\n## 結論\n使用 QPointer 可以更好的控管指向 Qt Object 的 Pointer，避免 initializer list 一堆 member data 要初始化，添加新的 member data 時忘記初始化的問題。\n只要依循 C++ Coding 的原則 -- 使用前先檢查是否為 Null，就可以避免指涉對象未創建、或已銷毀的情況了。\n\n## Reference \n- [What is the difference between QPointer, QSharedPointer and QWeakPointer classes in Qt?](https://stackoverflow.com/questions/22304118/what-is-the-difference-between-qpointer-qsharedpointer-and-qweakpointer-classes)"
    },
    {
        "metadata": {
            "title": "start-with-docsy-1",
            "date": "2024-05-03T12:05:00",
            "description": "啟動一個 docsy 主題的 hugo 網站"
        },
        "content": "## 開始之前\n\n使用主題有[多種方式](https://www.docsy.dev/docs/get-started/#installation-options)，官方最建議使用 Hugo Module 加載主題。\n\n本文將參考 [docsy-example](https://github.com/google/docsy-example)，嘗試用最少的設定從頭創建一個 docsy theme 的網站。\n\n### 版本資訊\n使用 docsy\\@v1.0，hugo version 和 go version 分別為\n```\ngo version go1.20.2 windows/amd64\nhugo v0.119.0+extended windows/amd64 BuildDate=unknown\n```\n注意 hugo 對 go 的版本有要求，錯誤的版本將無法執行 hugo command。\n\n\n## 初始化 Hugo Module \n嘗試從空白開始\n```bash\nmkdir customize-docsy\ncd customize-docsy\nhugo mod customize-docsy\n# go.mod is generated \n```\n\n這時資料夾中會有一個 `go.mod` 的檔案，內容如下: \n```go\nmodule customize-docsy\n\ngo 1.21.9\n```\n\n## 設置 hugo.yaml\nimport 的部分參考 docsy-example 創建一個檔案 `hugo.yaml`，內容如下: \n```yaml\nmodule:\n  # uncomment line below for temporary local development of module\n  # replacements: \"github.com/google/docsy -> ../../docsy\"\n  proxy: \"direct\"\n  hugoVersion:\n    extended: true\n    min: \"v0.119.0+extended\"\n  imports:\n    - path: \"github.com/google/docsy\"\n      disable: false\n    - path: \"github.com/google/docsy/dependencies\"\n      disable: false\n\n```\n\n### Replacement \n如果想把 module 導向 local 的位置，可以使用 replacements。有兩種方式，一種是寫在 go.mod，一種是寫在 hugo.yaml \n#### [go.mod](https://gohugo.io/hugo-modules/use-modules/#make-and-test-changes-in-a-module)\n\n```go\nreplace github.com/bep/hugotestmods/mypartials => /Users/bep/hugotestmods/mypartials\n```\n\n#### [hugo.yaml ](https://gohugo.io/hugo-modules/configuration/#module-configuration-top-level)\n如同範例中的註解寫到，如果想把 \"github.com/google/docsy\" 導向 local 的 docsy，就把該行 unconmment: \n\n```yaml\nreplacements: \"github.com/google/docsy -> ../../docsy\"\n```\n\n## 下載相關模組並執行\n```go\nhugo mod graph\nhugo server \n```\n前往 \"localhost:1313\"，因為是從頭創建，目前是一片空白。至此，已經成功套用主題，並且啟動 server。"
    },
    {
        "metadata": {
            "title": "start-with-docsy-2",
            "date": "2024-05-03T13:07:00",
            "description": "學習使用 Config，用最小的設定了解 docsy"
        },
        "content": "## 學習使用 Config\n\nConfig 內容繁雜，參考既有的會比較容易。個人認為 [docsy-example](https://github.com/google/docsy-example) 的 config 不容易參考，下面將提及另一個資源更容易讀。官方列出了[一些範例網站](https://www.docsy.dev/docs/examples/)，可以前往他們的 Github 找 config 參考。這裡提供兩個連結: \n- [Docsy official: Basic Config](https://www.docsy.dev/docs/get-started/basic-configuration/): 官方的文章\n- [kubeflow Config](https://github.com/kubeflow/website/blob/master/config.toml): 較簡單，且 config 有分區寫 comment，比官方範例網站更容易讀。\n\n## 簡易 Config\n參考自 kubeflow，我設置了較簡易的 config，讓啟動的網站有 Top-level navigation，不再是一片空白。\n\n```yaml\nbaseURL : \"/\"\ntitle : \"My Site\"\ndescription : \"This is a site with min settings.\"\n\n###############################################################################\n# Docsy\n###############################################################################\nenableGitInfo : false\n# language settings\ncontentDir : \"content/zh-tw\"\ndefaultContentLanguage : \"zh-tw\"\n# tell Hugo not to include the /en/ element in the URL path for English docs\ndefaultContentLanguageInSubdir : false\n# useful when translating\nenableMissingTranslationPlaceholders : true\n# disable taxonomies\ndisableKinds : [\"taxonomy\"]\n# deprecated directories\nignoreFiles : []\n\n###############################################################################\n# Hugo - Top-level navigation (horizontal)\n###############################################################################\n\nmenu:\n  main:\n    - name: \"Notes\"\n      weight: -102\n      pre: \"<i class='fas fa-book pr-2'></i>\"\n      url: \"/notes/\"\n    - name: \"Docs\"\n      weight: -101\n      pre: \"<i class='fas fa-book pr-2'></i>\"\n      url: \"/docs/\"\n    - name: \"Blogs\"\n      weight: -100\n      pre: \"<i class='fas fa-rss pr-2'></i>\"\n      url: \"/blogs/\"\n    - name: \"GitHub\"\n      weight: -99\n      pre: \"<i class='fab fa-github pr-2'></i>\"\n      url: \"https://github.com/\"\nmodule:\n  # uncomment line below for temporary local development of module\n  # replacements: \"github.com/google/docsy -> ../../docsy\"\n  proxy: \"direct\"\n  hugoVersion:\n    extended: true\n    min: \"v0.119.0+extended\"\n  imports:\n    - path: \"github.com/google/docsy\"\n      disable: false\n    - path: \"github.com/google/docsy/dependencies\"\n      disable: false\n```\n\n`module` 的部分來自前一篇文章。\n\n## 為類別建立類別首頁\n\n現在，local 網站上有 \"Event, Docs, Blogs\" 幾個 navigation option，但點進去內容卻是 404 。接下來將為各 option 建立該類別的首頁。\n\n首先創建 `contentDir `:\n\n```bash \nmkdir -p content/zh-tw\ncd content/zh-tw\n```\n\n接著建立 blog 資料夾、創建 `_index.md` 檔案\n\n```bash\nmkdir blog \ncd blog\ntouch _index.md\n```\n\n\n並編輯 `_index.md` 的內容: \n\n```markdown\n---\ntitle: Blog\n---\nContent here won't show in HTML.\n```\n\n再起一次 `hugo server`，blog 的頁面不再是 Not found，而是一片空白。反觀 `docs` 頁面還是404，說明這個 index page 是有效的。\n\n## Layouts\nDocsy 會偵測資料夾的名稱，決定套用的 layout。至於支援哪些類別，參考的 [layouts](https://github.com/google/docsy/tree/main/layouts) 。沒有特別列出來的類應該是套用 `_default`。\n\n### blogs\n不同的 layout 有不同的特點，在 docsy-example 中，`blog` 下又有兩個資料夾 : \"News\", \"Releases\"，文章會列在左邊欄位 (電腦版面)，並且會有 RSS 訂閱按鈕。\n注意`blog` layout 的 `_index.md` 內文的部分是不會顯示出來的! \n### docs\nDocs layout 沒有 RSS 訂閱按鈕，且 `_index.md` 的內容會顯示在 HTML 上。\n\n### 手動設定套用的 layout\n我們也可以在單一 markdown file 中，設置 meta data 指定 type 套用模板。\n```\ntype: blog\n```\n\n### 設定整個資料夾套用的類別\n每篇文章逐一設置不夠方便，我有一個類別為 \"Notes\" (content/zh-tw/notes)，但想套用 \"docs\" layout: \n\n1. 在 notes 資料夾底下創建 `_index.md`\n2. 設置 `_index.md` 內容如下\n\n    ```markdown\n    ---\n    title: Notes\n    description: \"Add description here\"\n    cascade:\n    - type: \"docs\"\n    ---\n    Some content\n    ```\n\n可以嘗試在 content/zh-tw/notes 底下創建其他文章，這些文章將套用 `docs` 的格式!"
    },
    {
        "metadata": {
            "title": "template-specilization-and-multiple-definition",
            "date": "2024-05-05T09:15:00",
            "description": "透過關鍵字 inline 解決 Template Specilization 遇到的 Multiple Definition",
            "categories": [
                "cpp"
            ]
        },
        "content": "雖然 Template 多習慣把實作寫在 hpp，若將 Template Specialiaztion 的**實作**寫在 hpp 卻可能發生問題。\n\n假設有三個檔案，`temp.hpp` 寫著 template 與 Template Specialiaztion 的實作，兩個 cpp: `main.cpp` 與 `func.cpp` 分別都有 include  `temp.hpp`。這會引發 multiple definition  [\\*](https://stackoverflow.com/questions/4445654/multiple-definition-of-template-specialization-when-using-different-objects)。\n\n```\n/usr/bin/ld: /tmp/ccDDhAUZ.o: in function `Negative get_max<Negative>(Negative, Negative)':\nmain.cpp:(.text+0x0): multiple definition of `Negative get_max<Negative>(Negative, Negative)'; /tmp/cctmE6oD.o:funcs.cpp:(.text+0x0): first defined here\ncollect2: error: ld returned 1 exit status\n```\n![template_spec_and_redefine](/image/template_spec_and_redefine.png)\n解決方法有兩種\n\n1. 宣告 Template Specialiaztion 於 hpp，實作放在 cpp\n2. 一樣把實作放在 hpp，但是多**宣告 inline** 於 Template Specialiaztion 的實作上。\n\n第一種方法還算好理解，但是為何宣告 inline 就可以解決 template specialiaztion 遇到的 multiple definition? 這關係 C++ 的一個原則: One Definition Rule.\n\n## One Definition Rule\n\n這其實相當有趣，因為 function 是否 inline 取決於 compiler，即使宣告 inline 也不一定代表 compiler 會真的對 function inline。\n\n那麼為何在 hpp 內對  Template Specialiaztion definition 宣告 inline 能解決問題?  [Stackoverflow 的回答](https://stackoverflow.com/a/48403514) 給出了解答。\n\n根據  C++ standard 條目 3.2:4 ([file](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf) P49 One definition rule)，可以拆成兩段來看: \n> (1) Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). \n> \n> (2) An inline function shall be defined in every translation unit in which it is ODR use.\n\n當 Specialiaztion 不是 inline 時被當作 non-inline function 對待，而對於 non inline function/variable，在 program 中只應該擁有一份 definition。因此兩次 include 同一份 template header 造成了問題: 多個 definition (include 的本質就是把 hpp 貼到 cpp 裡面)。\n\n當 Specialiaztion 是 inline 的時候，Specialiaztion 滿足了條目的第二部分: inline function 必須被定義於每一個使用到的 translation unit，也就是該則回答裡面提到的 : \n\n> an inline function must be defined in each module using the function.\n\n## Inline Object 的特性\n> 以下內容翻譯、解讀自 [CPP reference - inline specifier](https://en.cppreference.com/w/cpp/language/inline#:~:text=An%20inline%20function%20or%20inline,address%20in%20every%20translation%20unit.)\n\n當 function 或 variable (C++17) 被宣告為 inline，代表它擁有以下特性 (以下簡稱 inline object)\n\n1. 在每一個 TU (translation unit) 當中，inline object 的定義必須是可存取的。\n2. 如果一個 inline object 被宣告於 hpp，並且此 hpp 被多個 cpp inlcude，表示\n\t- 此 inline obejct 擁有 External Linkage (它的名稱在其他 TU 被引用且沒有被宣告 `static`)\n\t- 它在多個 TU 之間可能擁有**多個定義**，但在每一個 TU 的定義都是相同的。儘管具有這些特性，最終是否予以 inline subsititution 卻仍由 compiler 決定。\n## Inline 的歷史淵源\nSource: [Cpp Reference](https://en.cppreference.com/w/cpp/language/inline#:~:text=The%20original%20intent,statics%20listed%20above.)\n\nInline 這個關鍵字最初、最廣為人知的用意是把 function call 替換成 function body 本身，也就是 [inline substitution](https://en.wikipedia.org/wiki/inline_expansion \"enwiki:inline expansion\")。其代價是 object file 變大，因為每個 call 到 inline 的地方都會被「貼上」一次，但有優化的作用。\n\n然而，因為是否替換 function call 由 compiler 自由決定，被宣告 inline 的 function 不必然被替換，沒被宣告 inline 也不一定不被替換。這代表 inline function optimization 不在綁定於 keyword `inline`。\n\n需要注意的是，Compiler 選擇 inline optimization 與否，並不會改變有關 multiple definition 的規定。\n\n> Function 最終被 compiler inline 與否，都不應該擁有 multiple definition。\n\n在前面 「Inline Object 的特性」 提到，inline function 在多個 TU 當中是擁有多個定義 (multiple definitions) 的，且關鍵字 inline 並不與 inline subsititution 綁定。\n這個關鍵字的意義逐漸從「偏好 inline optimization」轉變成 「允許多重定義」，且這重含意在 C++17 中被延伸到 variable 上面。\n\n因此，當 Template Specialiaztion 透過 `inline` 可以解決 Multiple Definition 的原因，就來自於此。"
    },
    {
        "metadata": {
            "title": "thesis-markdown",
            "description": "以 Markdown 寫論文時的文獻、圖片公式等地引用管理，以及使用 pandoc 將 markdown 轉 doc 的操作。",
            "date": "2022-02-11T13:01:31",
            "categories": "Tool",
            "aliases": [
                "/posts/2022-02-11-thesis-markdown",
                "/posts/2022-02-11-thesis-markdown.html"
            ]
        },
        "content": "## Markdown vs. Latex\n\n主要是因為 Latex 語法有點過於繁雜，網路編輯器 Overleaf 雖然好用，但沒辦法直接輸入中文（或許要研究其他設定吧）。此外語法複雜，如果不是已經上手的人要寫通篇的長論文感覺有點負擔。\n\n相較之下，語法簡單的 Markdown 就好用很多，先大致在 markdown 把文字編輯的內容都完成，再去 word 套用統一格式，這是我選擇使用 Markdown 的原因。\n\n## PDF 生成\n\n套件 pandoc 可以直接將 markdown 轉成 PDF，但是預設的轉換引擎 pdflatex 、或是手動選定 xelatex 都需要下載完整的 Latex 套件。我在 Windows 安裝時被要求加了一堆東西，按得沒完又不想要它載東載西不告訴我，因此後來就改使用 wsl 端安裝跟執行 Pdf 操作。其中要注意中文文字的轉換，有可能需要指定字體！\n\n透過添加參數 `-V CJKmainfont=\"<some_font>.ttf\"`，並確認該字體檔可以被取得，最好是附在資料夾裡面。相關議題參照：[mactex 2015 報錯](https://github.com/ZJU-Awesome/write_with_LaTeX/issues/1)，字體檔案來源 [dolbydu: font/unicode](https://github.com/dolbydu/font/tree/master/unicode)。\n\n## 引用管理\n\n### 文獻文件：bib 檔案\n\n引用的部分採用 BibTex 管理文獻，使用 bibTex 必須遵守文獻規則撰寫並創建 `.bib` 檔案與。以 PanDoc 官網上的範例 bib 檔為例：\n\n- `@` 開頭作為一條新的引用\n- `@` 和大括弧 `{`之間表示此 Reference 所屬的類別，是書、文章、或其他類別。\n- 大括弧 `{` 後面的第一串字串，代表這條 reference 的 ID，在 markdown 中要如何引用它。\n\n```latex\n@Book{book1,\nauthor=\"John Doe\",\ntitle=\"First Book\",\nyear=\"2005\",\naddress=\"Cambridge\",\npublisher=\"Cambridge University Press\"\n}\n\n@Article{art1,\nauthor=\"John Doe\",\ntitle=\"Article\",\nyear=\"2006\",\njournal=\"Journal of Generic Studies\",\nvolume=\"6\",\npages=\"33-34\"\n}\n\n@InCollection{col1,\nauthor=\"John Doe and Jenny Roe\",\ntitle=\"Why Water Is Wet\",\nbooktitle=\"Third Book\",\neditor=\"Sam Smith\",\npublisher=\"Oxford University Press\",\naddress=\"Oxford\",\nyear=\"2007\"\n}\n```\n\nBibTex 格式所能設定的 Reference 類別總共有 14 種，參見：[Complete list of BibTeX entry types [with examples] - BibTeX.com](https://www.bibtex.com/e/entry-types/)。\n\n### 寫作文件：md 檔案\n\n建立一個 `demo.md` 檔案，內容如下。\n\n```markdown\n# demo \n根據文獻[@book1]所言，今天天氣真好。而文獻[@art1]提到，太陽會影響天氣。\n文獻[@col1]更是提到不但太陽會影響天氣，下雨、風也會。\n```\n\n經過指令調用 pandoc 來轉換成微軟 word 檔案：\n\n```shell\npandoc --cite --bibliography=biblio.bib demo.md -o demo-citation.docx\n```\n\nWord 產生的圖會在後面看到。\n\n### 文獻超連結\n\n上述方法產生的文件，在數字引用的部份只有單純的文字，沒辦法超連結到下面的參考文件區。根據 [PanDoc 官方文件](https://pandoc.org/MANUAL.html#other-relevant-metadata-fields)，這需要在 markdown 中添加 meta-data 把參數開起來：\n\n```markdown\n---\nlink-bibliography: true\nlink-citations: true\n---\n```\n\n### 調整文獻插入的格式\n\n我的領域並不慣用上面那種引用方式，要調整引用格式需要透過附加 `.csl` 檔案，上網查了 [IEEE 格式的 csl 檔案](https://github.com/citation-style-language/styles/blob/master/ieee.csl)。並在指令上添加 `--csl=ieee.csl` 參數：\n\n```shell\npandoc --cite --csl=ieee.csl --bibliography=biblio.bib demo.md \\\n\t-o demo-citation.docx\n```\n\n## 轉成 docx 時包含預設 MS Word 模板格式\n\n如果希望 docx 轉換成期望的格式，需要添加 `--reference-doc` 參數，我將論文格式儲存成 `render-sample.docx`，放在同一個資料夾。並且在 `.md` 最後加上了參考資料的標題，最後轉換效果如下：\n\n```sh\npandoc --cite --csl=ieee.csl \\\n        --bibliography=biblio.bib \\\n        --reference-doc=render-sample.docx demo.md -o cit.docx\n```\n\n![不同指令對應的結果](/uploads/4example-footnote.webp)\n\n```sh\npandoc --toc --cite --csl=ieee.csl \\\n\t  --filter pandoc-xnos --bibliography=biblio.bib \\\n\t  --reference-doc=render-sample.docx demo.md -o cit.docx\n```\n\n## 交互參照\n\n需下載套件 `pandoc-xnos`，並在下轉換指令的時候添加 `--filter pandoc-xnos`，其中包含四個套件，分別是：圖片 [pandoc-fignos](https://github.com/tomduck/pandoc-fignos)、公式 [pandoc-eqnos](https://github.com/tomduck/pandoc-eqnos)、表格 [pandoc-tablenos](https://github.com/tomduck/pandoc-tablenos)、章節 [pandoc-secnos](https://github.com/tomduck/pandoc-secnos)。\n\n可以直接在 pandoc 的轉換指令中添加  `--filter pandoc-xnos` 一口氣解決，也可以只取自己需要的 `--filter pandoc-fignos` 之類的，如果要同時使用兩個要加兩次參數，例如同時使用表格與圖片的參照 `--filter pandoc-fignos --filter-tablenos`。\n\n以下以表格與圖片的參照用法舉例說明。\n\n### 表格\n\n標註方法: `{#tbl:id}` ，`id` 可以自由換成此表格的專屬 id。\n\n```markdown\n|       | Col 1 | Col 2 |\n| ----- | ----- | ----- |\n| Row 1 | 11    | 12    |\n| Row 2 | 21    | 22    |\n| Row 3 | 31    | 32    |\nTable: 表格介紹 {#tbl:tbl1}\n```\n\n而想要參照(reference)某表格，則使用 `{@tbl:id}` 的方式參照。\n\n### 圖片\n\n標註方法: `{#fig:id}` 同樣 id 可以自由替換，參照方式也和表格雷同`{@fig:id}`。\n\n```\n![圖片介紹](path\\of\\fig){#fig:fig1}\n```\n\n### 公式參照\n\n使用套件 pandoc-eqnos，然而我按照教學中使用，轉換成 docx 時卻發生錯誤: XML Parsing error。這個問題主因應該是 Word 其實是一個 xml 格式的檔案，eqnos 的套件中哪裡把應對齊 xml 標籤給漏掉了，就好像 html 裡面 `<p>` 後面得要加 `</p>` 這樣成對式的 標籤(tag)。\n\n我依照文章 [[Office] 修復 Xml parsing error 的 Word Docx 檔案](https://ephrain.net/office-%E4%BF%AE%E5%BE%A9-xml-parsing-error-%E7%9A%84-word-docx-%E6%AA%94%E6%A1%88/) ，用網路上的線上 xml 分析網頁，解析了一下是哪裡發生狀況。發現就是在 `w:bookmarkStart` 附近出現 tag 有問題。最後，通過比較 pandoc-fignos 與 pandoc-eqnos ，發現兩份程式在 `bookmarkstart` 變數上處理不一樣! `fignos` 的程式碼沒有加上 `<w:r><w:t>`。\n\n因此，我把 eqnos 中的程式碼(約在 215行附近) 改成如下: \n\n```python\n        bookmarkstart = \\\n          RawInline('openxml',\n                    '<w:bookmarkStart w:id=\"0\" w:name=\"%s\"/>'\n                    %attrs.id)\n        bookmarkend = \\\n          RawInline('openxml',\n                    '<w:bookmarkEnd w:id=\"0\"/>')\n        ret = [bookmarkstart, AttrMath(*value), bookmarkend]\n```\n\n然後整個都可以順利引用了! 我不是很確定刪掉 `<w:r><w:t>` pair 之後，會不會對格式造成問題? 但如果圖片引用都這樣處理了，應該是還好? \n\n至於公式的引用與自動標號\n\n- 段落公式標號 (賦予公式 id )\n\n  ```markdown\n  $$\n  a+b=c\n  $${#eq:eq1} \n  ```\n\n- 引用有 id 的公式\n\n  ```markdown\n  如@eq:eq1之計算得到結果\n  ```\n\n- 給公式標號，但不賦予 ID \n\n  ```markdown\n  $$\n  a=999\n  $${#eq:} \n  ```\n\n效果參見範例文件。\n\n\n\n### meta-formatter\n\n抬頭的 meta-formatter 需要添加，cleveref 開啟的話參照圖表時前綴才會有「圖」或「表」，plus-name 是設定被參照時在內文中該以何種前綴顯示。\n\n```yaml\nfignos-cleveref: true\nfignos-plus-name: 圖\nfignos-caption-name: 圖\nfignos-number-by-section: true\nfignos-caption-separator: space # 預設為冒號\n\ntablenos-cleveref: true\ntablenos-plus-name: 表\ntablenos-caption-name: 表\ntablenos-number-by-section: true\n\neqnos-cleveref: true\neqnos-number-by-section: true\neqnos-plus-name: 公式 # 被引用時前綴詞為何\n```\n\n\n\n## 圖目錄與表目錄\n\n理論上可以在 meta-data 裡面設置這兩個參數自動生成，但似乎只支援生成 pdf，生成 word 時候這兩個參數不生效。\n\n```\nlof: true \nlot: true\n```\n\n要注意，雖然文章目錄的縮寫是 TOC (table of content)，但圖目錄與表目錄的縮寫分別是 lof (list of figure), lot (list of table) ，要用這個關鍵字去找! \n\n生成 PDF 的時候如果有報錯，注意是否為中文字 UTF-8 類字體所造成的轉換問題，相關議題參照前面章節[PDF生成](#PDF 生成)\n\n```sh\npandoc --cite --csl=ieee.csl --filter pandoc-xnos \\\n\t\t--bibliography=biblio.bib --pdf-engine=xelatex \\\n\t\t-V CJKmainfont=\"KaiTi.ttf\" --reference-doc=render-sample.docx demo.md \\\n\t\t-o cit.pdf\n\t\t\n# 或將 fignos 與 tablenos 分開列\npandoc --cite --csl=ieee.csl \\\n\t\t--filter pandoc-fignos --filter pandoc-tablenos \\\n\t\t--bibliography=biblio.bib --pdf-engine=xelatex \\\n\t\t-V CJKmainfont=\"KaiTi.ttf\" --reference-doc=render-sample.docx demo.md \\\n\t\t-o cit.pdf\n```\n\n## 包含交互參照的 Word 轉換指令\n\n但經過我的實驗，雖然這一連串的操作可以使圖表依照章節標號，卻沒辦法有標號超連結之類的，恐怕也沒辦法在 word 裡面生成圖目錄與表目錄。\n\n```sh\npandoc  --filter pandoc-xnos \\\n\t\t--cite --csl=ieee.csl --bibliography=biblio.bib \\\n        --pdf-engine=xelatex \\\n\t\t-V CJKmainfont=\"KaiTi.ttf\" --reference-doc=render-sample.docx demo.md \\\n\t\t-o cit.docx\n```\n\n## 分頁符號\n\nMarkdown 本身是不支援分頁符號的，但我們可以使用 html code 讓它強制分頁：[Markdown 輸出 pdf 強制分頁的方法](https://github.com/hanxi/blog/issues/20) （但轉成 doc 後時靈時不靈，用 Latex 語法 `\\newpage` 也一樣，我後來就直接從 doc 模板那邊下手：每個大標題都自動換頁）。\n\n```html\n<div style=\"page-break-after: always;\"></div>\n```\n\n但是如果轉成 PDF 的話，在 markdown 中直接輸入 `\\newpage` 作為分頁是可行的。\n\n轉成 doc 時的強制分頁(分頁符號)，需要直接插入一段 source code ：\n\n```xml\n<w:p>\n  <w:r>\n    <w:br w:type=\"page\"/>\n  </w:r>\n</w:p>\n```\n\n因為 ms word 本身是一個 xml 格式的檔案，pandoc 在轉換時對 docx 支援這種[部份 raw attribute](https://pandoc.org/MANUAL.html#extension-raw_attribute) 的功能，可以透過此方法達成強制分頁。\n\n## 在 WSL 安裝 Latex\n\n我用的是 Ubuntu 做為 Wsl2 的作業系統。首先安裝 Latex 基本的語法與擴充語法：\n\n```sh\nsudo apt-get install texlive\nsudo apt-get install texlive-latex-extra\nsudo apt-get install texlive-xetex\n```\n\n接著依照 [Pandoc 的官方文件](https://github.com/jgm/pandoc/blob/master/INSTALL.md#linux)選擇適合的檔案：\n\n```sh\nwget https://github.com/jgm/pandoc/releases/download/2.17.1.1/pandoc-2.17.1.1-1-amd64.deb\nsudo dpkg -i pandoc-2.17.1.1-1-amd64.deb\n```\n\n並且在 Markdown 中引用的圖片，最好是放在同層級或下層級的資料夾中，比較不容易發生圖片找不到的狀況。\n\n## 範例\n\n範例 markdown 與轉換而成的 MS Word 如下，內文是產生器而得，完全只是要個排版的感覺，請勿深究！轉換指令：\n\n```sh\npandoc --filter pandoc-xnos \\\n\t--cite --csl=ieee.csl --bibliography=biblio.bib \\\n\t--pdf-engine=xelatex -V CJKmainfont=\"KaiTi.ttf\" \\\n\t--reference-doc=render-sample.docx demo.md \\\n\t-o cit.docx\n```\n- 所使用的 markdown 檔案、bib 引用檔案以及輸出的 word 檔案： [markdown-thesis.zip](/uploads/markdown-thesis.zip)。\n- render-sample 為個人的 doc 模板。\n\n## Reference\n\n- [Markdown、.bib、LaTeX + Typora、Pandoc 管理論文文獻](https://blog.csdn.net/qq_39564555/article/details/112496861)\n- [using bibtex: a short guide](https://www.economics.utoronto.ca/osborne/latex/BIBTEX.HTM)"
    },
    {
        "metadata": {
            "title": "vscode-setting",
            "description": "到一個新環境必做的基本設置，如何連線到遠端機器等。",
            "date": "2022-06-23T11:52:45",
            "categories": "Tool",
            "aliases": [
                "/posts/2022-06-23-vscode-setting",
                "/posts/2022-06-23-vscode-setting.html"
            ]
        },
        "content": "有如 Spyder 的 IPython 互動介面、直接用 VSCode 以 SSH 遠端連線、VSCode 的 anaconda 切換問題等等，有些可能按照 Reference 的做法就成功了，有些會加一些自己的嘗試，所有個人經歷過的問題都記錄在本文中! \n<!--more-->\n\n## Vscode 中的 Anaconda 虛擬環境切換問題\n\n[VScode中Anaconda虚拟环境切换的问题（Python+Jupyter）](https://blog.csdn.net/Ocean_waver/article/details/108306791)\n\n### 情況\n\n即便執行時已經改使用虛擬環境的 python.exe ，但是執行命令時仍常常失敗: 「找不到指定的模組」\n\n### 解決\n\n原因是 Vscode使用的是 powershell 模式，而不是 cmd模式。\n\n透過在預設的 setting.json (`C://User//XXX/AppData/Roaming/Code/User/setting.json`)中，添加指定的終端機執行模式：改指向 cmd.exe\n\n```bash\n\"terminal.integrated.shell.windows\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\",\n```\n\n## 在 terminal 中使用 iPython kernel\n\n請先看看 [Interactive Mode](#使用-Vscode-預設的-Interactive-mode) 是不是更貼近需求！這兩者的設定上可能會有衝突\n\n這邊指的是像 spyder 那樣，可以在側邊欄位 key 東西，而不是像 Jupyter 那樣一個個 block。\n\n### 需求\n\n1. 基本的需要有 python 程式，IPython (pip install)\n2. vscode 除了Python 插件，還要額外安裝 multi-command 插件 (支援多步驟的命令)\n\n### 設定檔\n\n1. `setting.json`\n\n   ```json\n   \"python.terminal.launchArgs\": [\"-m\", \"IPython\", \"--no-autoindent\"],     \n   \"multiCommand.commands\": [\n       {\n           \"command\": \"multiCommand.executeIPython\",\n           \"sequence\": [\n               \"python.execSelectionInTerminal\",\n               \"workbench.action.terminal.focus\",\n               \"workbench.action.terminal.scrollToBottom\",\n               {\"command\": \"workbench.action.terminal.sendSequence\",\n                \"args\": { \"text\": \"\\u000D\" }},\n               \"workbench.action.focusActiveEditorGroup\"\n           ]\n       },\n   ]\n   ```\n\n2. `keybindings.json`\n\n   ```json\n   {\n   \"key\": \"shift+enter\", \n   \"command\": \"multiCommand.executeIPython\",\n   \"when\": \"editorTextFocus && python.datascience.featureenabled && python.datascience.ownsSelection && !findInputFocussed && !notebookEditorFocused && !replaceInputFocussed && editorLangId == 'python'\" \n   },\n   ```\n\n### 參考\n\n- [Use IPython REPL in VS Code](https://stackoverflow.com/questions/52310689/use-ipython-repl-in-vs-code/52324509#answer-59485636)\n- [Python の 在 VSCode 中使用 IPython Kernel 的方法](https://codingnote.cc/zh-tw/p/191622/)\n\n## SSH Remote setting\n\n- [使用 Visual Studio Code 透過 SSH 進行遠端程式開發](https://xenby.com/b/221-%E6%95%99%E5%AD%B8-%E4%BD%BF%E7%94%A8-visual-studio-code-%E9%80%8F%E9%81%8E-ssh-%E9%80%B2%E8%A1%8C%E9%81%A0%E7%AB%AF%E7%A8%8B%E5%BC%8F%E9%96%8B%E7%99%BC)：現在一般的公開版就可以找到這個模組了！\n\n1. 在 vscode 中下載模組：Remote Development （現在在一般版也可以下載了）\n2. 輸入要連線的伺服器：`account@IP -p port`，確認後 enter\n3. 會出現一個下拉式選單，列出一些 config 的位置，意思是要把這個 ssh 連線的設定存到哪個 config 裡面。反之，要調整已經紀錄的連線內容，也是在這個 config 裡面。選取要儲存的檔案 (我存在 `C:\\User\\user\\.ssh\\config`)\n4. 再一次連線\n5. 輸入密碼\n6. 等待遠端完成一些同步的下載，當左下角顯示的是你的遠端IP，就代表連線成功了\n\n### Find IP \n\n嘗試 `ifconfig`, `ipconfig` 或 `cat /etc/hosts` 查看! \n\n###  意外\n\n通常應該是按照[官方教學](https://code.visualstudio.com/docs/remote/ssh) 就可以了，但是我剛才出現了\n\n```\n[11:32:55.138] Resolver error: Error: XHR failed at XMLHttpRequest.s.onerror (file:///C:/Program Files/Microsoft VS Code/resources/app/out/vs/workbench/workbench.desktop.main.js:462:158)\n```\n\n參考了[How can I install vscode-server in linux offline](https://stackoverflow.com/questions/56671520/how-can-i-install-vscode-server-in-linux-offline)\n\n在 code-server 資料夾下多放一個檔案\n\n```\ntouch ~/.vscode-server/bin/${commit_id}/0\n```\n\n再重新從 vscode 連一次 ssh 進去，就成功拉!\n\n**參考** : 過程中調查到這個網站，或許會有幫助，但沒有實驗 https://github.com/cdr/code-server\n\n## SSH Remote key\n\n- [使用VSCode Remote透過 SSH 進行遠端開發](https://hackmd.io/@brick9450/vscode-remote) ：用其他模組記住密碼\n- [如何使用 SSH 遠端連線？](https://www.maxlist.xyz/2020/03/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ssh-%E9%81%A0%E7%AB%AF%E9%80%A3%E7%B7%9A%EF%BC%9F/)：使用 ssh 連線，不用輸入密碼就能登入遠端裝置\n\n但每次登入的時候都要輸入密碼，改用 SSH 可以免除每次都要 key 密碼！\n\n1. 在自己（local）電腦：`ssh-keygen`，直接按 enter 就是產生在預設的資料夾，不使用密碼。\n2. 資料夾中，`id_rsa.pub` 是公鑰、`id_rsa` 是私鑰。\n3. 用 wordpad 之類的編輯器開啟公鑰，複製。\n4. 把公鑰放到遠端電腦的 `~/.ssh/authorized_keys` 檔案裡面：\n   A. 使用 Vim 修改\n   - 在遠端電腦上輸入 `vim ~/.ssh/authorized_keys`\n   - 貼上公鑰\n   - 按 `:wq` 儲存並離開\n   B. 或者，vim 太難用了，不如改用 vscode 吧! \n   - 在遠端電腦上輸入 `code ~/.ssh/authorized_keys`\n   - 貼上公鑰、儲存、離開! \n5. 再一次用 vscode 登入遠端連線，應該可以不用 key 密碼了！\n\n## Port forwarding\n\n如果使用遠端作為 Server，其local host 在遠端機器上，沒辦法從本地取得。這時候需要使用到 port 的映射。以 Docker 的官方新手教學為例: 我嘗試在遠端機器 tx2 上建立了一個網頁伺服器: `localhost:3000`，但在我的電腦上無法取得這個網頁。\n\n於是，在左邊欄位的「連接阜」直接打`3000`，然後在本地的 web 打開 `localhost:3000`，就能連線上去了! 或是如果滑鼠放在在 vscode 「連接阜」下面的內容的某行上，右邊會出現一個地球，也可以直接點擊連上!\n\n## GUI 也能透過SSH傳送過來\n\n[VSCODE 实现远程GUI，显示plt.plot， 设置x11端口转发](https://blog.csdn.net/zb12138/article/details/107160825)\n[vscode + remote x11插件 +xserver 终端实现远程GUI显示](https://www.jianshu.com/p/66875a1f294b)\n\n在 mobaxterm 的時候 `plt.show()`，或是 qt GUI 都能透過 ssh 傳送過來，這是因為 Moba 裡面自帶 Xterm 的關係。\n\n1. 在 Vscode, xterminal 是需要額外使用插件的：\n   (1) Remote X11 裝在遠端\n   (2) Remote X11 (SSH) 裝在本地\n2. 需要把 public key 放到遠端的 `~/.ssh/authorized_keys` 裡面。\n3. 本地需要載 Xserver，也可以只是打開 mobaXterm 放在那也行。\n4. Vscode 裡面 F1後, 打  Remote X11 : Reconnect Display，有彈出通知表示 OK 就可以了 （我的經驗，不OK是因為沒有把公鑰授權過去）\n5. 輸入一些 GUI 的測試指令，看有沒有成功，成功的話會看到一雙眼睛或是一顆時鐘跳出來～！\n\n```\nxeyes\nxclock\n```\n\n## 不讓遠端機器記住歷史指令\n\n- [Linux command history: Choosing what to remember and how](https://www.networkworld.com/article/3256279/linux-command-history-choosing-what-to-remember-and-how.html)\n- [iT 邦幫忙鐵人賽 DAY 23~30 整合式終端機](https://taichunmin.idv.tw/blog/2019-10-16-ithelp-ironman-09.html)\n\n在 User 的 `settings.json` 中設定 (`c:User/user/AppData/Roaming/Code/User/settings.json`)\n\n```json\n{\n    \"terminal.integrated.defaultProfile.linux\": \"\",\n    \"terminal.integrated.shell.linux\": [ \"export HISTCONTROL=ignorespace\" ], // 這行\n    \"terminal.integrated.inheritEnv\": false // 這是 vscode 建議如果有啟用 conda 的話設定 false.\n}\n```\n\n## Terminal 突然字母都變成全形\n\nhttps://github.com/microsoft/vscode/issues/120004\n\n這是 windows 大小突然改變的問題，重新縮放可以解決。\n\n## 使用 Vscode 預設的 Interactive mode\n\n看看這個影片 [VSCode's Python Interactive mode is AMAZING!](https://www.youtube.com/watch?v=lwN4-W1WR84) 。只要在 .py 中，某個段落的 code 前面加上 `# %%` ，它就會自動跳出一個 block \n\n- Run cell : 只執行這個 block \n- Run below : 應該是一路往下所有的 cell 都執行\n- Debug cell : 對這個 blog 使用 vscode 的偵錯模組。\n\n沒有安裝 jupyter 套件沒關係，在嘗試執行 block 時它發現沒有 ipykernel 編譯器就會建議你安裝 Jupyter 了，按照建議的安裝即可。但個人覺得比起第二點在 terminal 裡面開 ipython ，jupyter 的連線比較慢，一段時間不碰還會自動斷線，有點麻煩。\n\n## [改主題](https://code.visualstudio.com/docs/getstarted/themes)\n\n這邊要說的是基於某主題，進而更改某些不喜歡的設定。\n\n- `workbench.colorCustomizations` 能改變的是 vscode 框架。導覽 bar、整體背景等等。\n  - `\"sideBar.background\"`: 指的是[左邊檔案總管](https://code.visualstudio.com/api/references/theme-color#editor-groups-tabs)那邊\n  - `\"editor.findMatchHighlightBackground\"` : 所有被搜尋到匹配的文字的底色。\n- `\"editor.tokenColorCustomizations\"` : 管理的是語法的顏色。\n  - `\"comments\"` : 所有註解的顏色。我覺得許多預設主題為註解選擇墨綠色很不清楚，改成紫羅蘭色。\n\n\n```json\n    \"workbench.colorTheme\": \"Default High Contrast\", // 當前所選用的主題\n    \"workbench.colorCustomizations\" : {\n        \"[Default High Contrast]\":{            \n            \"sideBar.background\": \"#347890\", // 其實不建議改成這個顏色, 只是改變顯眼列在這裡\n            \"editor.findMatchHighlightBackground\": \"#ffff3f70\",\n        }\n    }, \n    \"editor.tokenColorCustomizations\":{\n        \"comments\": \"#85b4ff\",\n\n    }\n```"
    },
    {
        "metadata": {
            "title": "_index",
            "description": "筆記收藏處",
            "cascade": [
                {
                    "type": "blog"
                }
            ]
        },
        "content": "這裡將收集各種筆記，可能是使用 Python 模組的經驗、建立網站的經驗、隨手寫的腳本、蒐集整理的資訊...。"
    }
]